```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minecraft Seed Generator Ultimate</title>
    <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <style>
        body { background-color: #1a1a1a; color: #e0e0e0; font-family: 'Arial', sans-serif; margin: 0; padding: 0; }
        .scrollbar-custom::-webkit-scrollbar { width: 8px; }
        .scrollbar-custom::-webkit-scrollbar-track { background: #2b2b2b; }
        .scrollbar-custom::-webkit-scrollbar-thumb { background: #4caf50; border-radius: 4px; }
        .scrollbar-custom::-webkit-scrollbar-thumb:hover { background: #66bb6a; }
        .container { display: flex; flex-direction: column; min-height: 100vh; }
        @media (min-width: 768px) {
            .container { flex-direction: row; }
        }
        .panel { padding: 1.5rem; }
        .control-panel { 
            width: 100%; 
            background-color: #1f2937; 
            order: 2; 
        }
        @media (min-width: 768px) {
            .control-panel { 
                width: 24rem; 
                order: 1; 
                max-height: 100vh; 
                overflow-y: auto; 
            }
        }
        .map-panel { 
            flex: 1; 
            padding: 1rem; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            order: 1; 
        }
        @media (min-width: 768px) {
            .map-panel { 
                order: 2; 
                padding: 1.5rem; 
            }
        }
        .canvas-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            height: 400px;
        }
        canvas {
            border: 2px solid #374151;
            border-radius: 0.5rem;
            background-color: #111827;
            width: 100%;
            height: 100%;
            display: block;
        }
        .btn {
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            border: none;
            font-weight: 500;
            transition: all 0.2s;
            cursor: pointer;
            text-align: center;
        }
        .btn-primary { background-color: #10b981; color: white; }
        .btn-primary:hover { background-color: #0d9488; }
        .btn-primary:disabled { background-color: #6b7280; cursor: not-allowed; }
        .btn-secondary { background-color: #3b82f6; color: white; }
        .btn-secondary:hover { background-color: #2563eb; }
        .btn-danger { background-color: #ef4444; color: white; }
        .btn-danger:hover { background-color: #dc2626; }
        .btn-warning { background-color: #f59e0b; color: white; }
        .btn-warning:hover { background-color: #d97706; }
        .btn-success { background-color: #10b981; color: white; }
        .btn-success:hover { background-color: #0d9488; }
        .input, select {
            width: 100%;
            padding: 0.5rem;
            border-radius: 0.375rem;
            border: 1px solid #4b5563;
            background-color: #374151;
            color: white;
            margin-bottom: 0.5rem;
        }
        .input-range {
            width: 100%;
            margin-bottom: 0.5rem;
        }
        .error-message {
            color: #ef4444;
            font-size: 0.875rem;
            margin-bottom: 1rem;
            padding: 0.5rem;
            background-color: #3f1717;
            border-radius: 0.375rem;
        }
        .progress-container {
            width: 100%;
            height: 0.5rem;
            background-color: #374151;
            border-radius: 999px;
            margin-bottom: 0.5rem;
            overflow: hidden;
        }
        .progress-bar {
            height: 100%;
            background-color: #10b981;
            border-radius: 999px;
            transition: width 0.2s;
        }
        .result-textarea {
            width: 100%;
            min-height: 120px;
            background-color: #374151;
            color: white;
            border-radius: 0.375rem;
            padding: 0.5rem;
            resize: vertical;
            font-family: monospace;
            font-size: 0.875rem;
        }
        .flex {
            display: flex;
        }
        .flex-col {
            flex-direction: column;
        }
        .flex-row {
            flex-direction: row;
        }
        .gap-2 {
            gap: 0.5rem;
        }
        .gap-4 {
            gap: 1rem;
        }
        .mb-2 {
            margin-bottom: 0.5rem;
        }
        .mb-4 {
            margin-bottom: 1rem;
        }
        .mt-4 {
            margin-top: 1rem;
        }
        .text-sm {
            font-size: 0.875rem;
        }
        .text-lg {
            font-size: 1.125rem;
        }
        .font-bold {
            font-weight: 700;
        }
        .text-green-400 {
            color: #10b981;
        }
        .grid {
            display: grid;
        }
        .grid-cols-2 {
            grid-template-columns: repeat(2, 1fr);
        }
        .items-center {
            align-items: center;
        }
        .justify-between {
            justify-content: space-between;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        // Enhanced Constants with improved structure data
        const Constants = {
            STRUCTURES: {
                Village: { spacing: 32, minDist: 8, weight: 1.0, yRange: [-64, 319], types: ["Plains", "Desert", "Savanna", "Snowy", "Taiga", "Meadow"] },
                Mineshaft: { spacing: 1, minDist: 1, weight: 0.8, yRange: [-64, 30], types: ["Normal", "Mesa"] },
                Stronghold: { spacing: 16, minDist: 1, weight: 1.0, yRange: [-64, 30], special: true },
                Temple: { spacing: 32, minDist: 8, weight: 0.9, yRange: [-64, 319], types: ["Desert", "Jungle", "Swamp", "Igloo"] },
                Monument: { spacing: 32, minDist: 5, weight: 0.7, yRange: [0, 63], underwater: true },
                Mansion: { spacing: 80, minDist: 20, weight: 0.5, yRange: [60, 319], exclusive: true },
                "Bastion Remnant": { spacing: 27, minDist: 10, weight: 0.8, yRange: [0, 128], types: ["Bridge", "Hoglin Stable", "Housing Units", "Treasure"] },
                "Ancient City": { spacing: 24, minDist: 8, weight: 0.7, yRange: [-64, 0], deepslate: true },
                "Nether Fortress": { spacing: 16, minDist: 5, weight: 0.9, yRange: [0, 128], nether: true },
                "Trial Chambers": { spacing: 32, minDist: 8, weight: 0.6, yRange: [-64, 30], types: ["Small", "Medium", "Large"] },
                "End City": { spacing: 20, minDist: 11, weight: 0.8, yRange: [0, 256], end: true },
                "Ruined Portal": { spacing: 25, minDist: 8, weight: 0.9, yRange: [-64, 319], types: ["Standard", "Giant"] }
            },
            BIOME_WEIGHTS: {
                OVERWORLD: {
                    Plains: 0.35, Forest: 0.25, Desert: 0.15, Taiga: 0.15, Swamp: 0.10,
                    Jungle: 0.05, Savanna: 0.12, Badlands: 0.05, "Mushroom Fields": 0.005,
                    "Deep Dark": 0.04, "Mangrove Swamp": 0.05, "Cherry Grove": 0.03,
                    "Lush Caves": 0.04, "Snowy Plains": 0.08, Ocean: 0.25,
                    Meadow: 0.05, "Bamboo Jungle": 0.02, "Frozen Ocean": 0.08,
                    "Birch Forest": 0.12, "Dark Forest": 0.08, "Giant Tree Taiga": 0.06,
                    "Stone Shore": 0.03, "River": 0.15, "Beach": 0.05
                },
                NETHER: {
                    "Nether Wastes": 0.30, "Crimson Forest": 0.25, "Warped Forest": 0.25,
                    "Soul Sand Valley": 0.15, "Basalt Deltas": 0.05
                },
                END: {
                    "End Highlands": 0.40, "End Midlands": 0.30, "End Barrens": 0.20,
                    "Small End Islands": 0.10
                }
            },
            WORLD_SETTINGS: {
                CHUNK_SIZE: 16,
                MAX_HEIGHT: 319,
                MIN_HEIGHT: -64,
                SEARCH_ITERATIONS: 50000, // Increased from 20000
                STRUCTURE_REGION_BITS: 12,
                MAX_CACHED_RESULTS: 1000,
                NOISE_OCTAVES: 8,
                NOISE_PERSISTENCE: 0.5,
                NOISE_SCALE: 0.007,
                BIOME_ANALYSIS_RADIUS: 4000,
                SPAWN_CHECK_RADIUS: 32
            },
            LOOT_TABLES: {
                Village: ["iron", "food", "emeralds", "tools", "armor"],
                Temple: ["gold", "diamonds", "emeralds", "potions", "enchanted_books"],
                Monument: ["gold", "sponge", "prismarine", "tridents", "nautilus_shells"],
                "Ancient City": ["echo_shards", "disc_fragments", "enchanted_books", "suspicious_stew", "ward_armor"],
                "Nether Fortress": ["nether_wart", "blaze_rods", "wither_skulls", "gold", "netherite_scrap"],
                "Trial Chambers": ["diamonds", "enchanted_equipment", "trial_key", "experience_bottles"]
            }
        };

        // Extract spacing from Constants
        const spacing = Object.fromEntries(
            Object.entries(Constants.STRUCTURES).map(function(entry) {
                return [entry[0], entry[1].spacing];
            })
        );

        // Enhanced Minecraft Random with better seed handling
        function MinecraftRandom(seed) {
            // Ensure seed is a BigInt and properly masked
            let instanceSeed = typeof seed === 'bigint' ? seed : BigInt(seed);
            instanceSeed = instanceSeed & ((BigInt(1) << BigInt(48)) - BigInt(1));
            
            return {
                nextInt: function(bound) {
                    if (bound <= 0) throw new Error("Bound must be positive");
                    instanceSeed = (instanceSeed * BigInt(0x5DEECE66D) + BigInt(0xB)) & ((BigInt(1) << BigInt(48)) - BigInt(1));
                    return Number(instanceSeed >> BigInt(16)) % bound;
                },
                nextFloat: function() {
                    instanceSeed = (instanceSeed * BigInt(0x5DEECE66D) + BigInt(0xB)) & ((BigInt(1) << BigInt(48)) - BigInt(1));
                    return Number(instanceSeed >> BigInt(24)) / (1 << 24);
                },
                nextLong: function() {
                    instanceSeed = (instanceSeed * BigInt(0x5DEECE66D) + BigInt(0xB)) & ((BigInt(1) << BigInt(48)) - BigInt(1));
                    return instanceSeed;
                }
            };
        }

        // Enhanced Perlin Noise with better interpolation
        function perlinNoise(x, z, seed, scale, octaves) {
            if (scale === undefined) scale = Constants.WORLD_SETTINGS.NOISE_SCALE;
            if (octaves === undefined) octaves = Constants.WORLD_SETTINGS.NOISE_OCTAVES;
            
            let total = 0;
            let frequency, amplitude;
            
            for (let i = 0; i < octaves; i++) {
                frequency = scale * Math.pow(2, i);
                amplitude = Math.pow(Constants.WORLD_SETTINGS.NOISE_PERSISTENCE, i);
                
                // Use the seed to create a unique random generator for each octave
                const randSeed = seed + BigInt(i * 1000);
                const rand = MinecraftRandom(randSeed);
                
                // Grid coordinates
                const gridX = Math.floor(x * frequency);
                const gridZ = Math.floor(z * frequency);
                
                // Random values at grid points
                const n00 = rand.nextFloat() * 2 - 1;
                const n10 = rand.nextFloat() * 2 - 1;
                const n01 = rand.nextFloat() * 2 - 1;
                const n11 = rand.nextFloat() * 2 - 1;
                
                // Fractional part for interpolation
                const fx = (x * frequency) - gridX;
                const fz = (z * frequency) - gridZ;
                
                // Improved interpolation using smootherstep
                const u = fx * fx * (3 - 2 * fx); // Smoothstep
                const v = fz * fz * (3 - 2 * fz);
                
                // Bilinear interpolation
                const lerpX0 = n00 + u * (n10 - n00);
                const lerpX1 = n01 + u * (n11 - n01);
                const noiseValue = lerpX0 + v * (lerpX1 - lerpX0);
                
                total += noiseValue * amplitude;
            }
            
            return total;
        }

        // Get biome at position with enhanced accuracy
        function getBiomeAt(seed, x, z, version, dimension) {
            try {
                if (typeof seed === 'string') {
                    seed = BigInt(seed);
                }
                
                if (dimension === undefined) dimension = "overworld";
                const biomeMap = Constants.BIOME_WEIGHTS[dimension.toUpperCase()] || Constants.BIOME_WEIGHTS.OVERWORLD;
                
                // Use a more complex noise seed calculation
                const noiseSeed = seed + BigInt(x) * BigInt(341873128712) + BigInt(z) * BigInt(132897987541);
                const noise = perlinNoise(x, z, noiseSeed, Constants.WORLD_SETTINGS.NOISE_SCALE, Constants.WORLD_SETTINGS.NOISE_OCTAVES);
                
                // Map noise to biome index with better distribution
                const biomeId = Math.floor((noise + 1) * 100);
                let cumWeight = 0;
                
                for (const biome in biomeMap) {
                    cumWeight += biomeMap[biome] * 100;
                    if (biomeId <= cumWeight) {
                        return [biome, 1];
                    }
                }
                
                // Fallback biome
                return ["Plains", 1];
            } catch (error) {
                console.error("Error in getBiomeAt:", error);
                return ["Plains", 1];
            }
        }

        // Structure position calculation with improved accuracy
        function getStructurePos(seed, structure, version, radius, filters) {
            try {
                if (filters === undefined) filters = {};
                const versionNum = parseFloat(version);
                
                // Define biome requirements for structures
                const biomeRequirements = {
                    Village: ["Plains", "Desert", "Savanna", "Taiga", "Meadow", "Snowy Plains"],
                    Temple: ["Desert", "Jungle", "Swamp", "Snowy Plains"],
                    Monument: ["Ocean", "Deep Ocean", "Warm Ocean"],
                    Mansion: ["Dark Forest", "Flower Forest"],
                    "Ancient City": ["Deep Dark"],
                    "Bastion Remnant": ["Nether Wastes", "Crimson Forest", "Warped Forest", "Soul Sand Valley", "Basalt Deltas"],
                    "Nether Fortress": ["Nether Wastes", "Crimson Forest", "Warped Forest", "Soul Sand Valley", "Basalt Deltas"],
                    "Trial Chambers": ["Deep Dark"],
                    "Stronghold": ["Plains", "Desert", "Forest", "Taiga", "Jungle", "Swamp", "Mesa"]
                };
                
                // Calculate structure-specific seed
                let structureSeed = seed;
                for (let i = 0; i < structure.length; i++) {
                    structureSeed = (structureSeed * 31 + BigInt(structure.charCodeAt(i))) & ((BigInt(1) << BigInt(48)) - BigInt(1));
                }
                
                const rand = MinecraftRandom(seed + structureSeed);
                const minDist = Constants.STRUCTURES[structure].minDist;
                let blockX, blockZ;
                
                // Special handling for Stronghold in older versions
                if (structure === "Stronghold" && versionNum < 1.18) {
                    const ring = rand.nextInt(3);
                    const minRadius = [1408, 2720, 4032][ring];
                    const maxRadius = [2688, 4000, 5312][ring];
                    const angle = rand.nextFloat() * 2 * Math.PI;
                    const distance = minRadius + rand.nextFloat() * (maxRadius - minRadius);
                    blockX = Math.round(Math.cos(angle) * distance);
                    blockZ = Math.round(Math.sin(angle) * distance);
                } else {
                    // Standard structure placement
                    const regionSize = spacing[structure] * Constants.WORLD_SETTINGS.CHUNK_SIZE;
                    const maxRegions = Math.floor(radius / regionSize);
                    
                    // Random region selection with better distribution
                    const regionX = rand.nextInt(maxRegions * 2) - maxRegions;
                    const regionZ = rand.nextInt(maxRegions * 2) - maxRegions;
                    
                    // Random position within region
                    blockX = (regionX * regionSize) + rand.nextInt(regionSize);
                    blockZ = (regionZ * regionSize) + rand.nextInt(regionSize);
                }
                
                // Calculate distance from origin
                const distance = Math.sqrt(blockX * blockX + blockZ * blockZ);
                
                // Check if position is within radius and minimum distance
                if (distance <= radius && distance >= minDist * Constants.WORLD_SETTINGS.CHUNK_SIZE) {
                    // Apply stronghold distance filter
                    if (filters.stronghold_distance && structure === "Stronghold" && distance > filters.stronghold_distance) {
                        return null;
                    }
                    
                    // Determine dimension for biome check
                    const checkDimension = ["Bastion Remnant", "Nether Fortress"].includes(structure) ? "nether" : "overworld";
                    
                    // Check multiple points around structure for biome compatibility
                    const checkOffsets = [
                        [0, 0], [8, 8], [-8, -8], [8, -8], [-8, 8],
                        [16, 0], [-16, 0], [0, 16], [0, -16]
                    ];
                    
                    for (const offset of checkOffsets) {
                        const dx = offset[0], dz = offset[1];
                        const biomeResult = getBiomeAt(seed, blockX + dx, blockZ + dz, version, checkDimension);
                        const biome = biomeResult[0];
                        
                        // Skip biome check for structures without specific requirements
                        if (biomeRequirements[structure] && !biomeRequirements[structure].includes(biome)) {
                            return null;
                        }
                    }
                    
                    // Add structure-specific description
                    let desc = structure;
                    if (structure === "Temple") {
                        const templeTypes = ["Desert", "Jungle", "Swamp", "Igloo"];
                        const templeType = templeTypes[rand.nextInt(templeTypes.length)];
                        if (filters.temple_type && filters.temple_type !== "Any" && templeType !== filters.temple_type) return null;
                        desc = "Temple (" + templeType + ")";
                    } else if (structure === "Bastion Remnant") {
                        const bastionTypes = ["Hoglin Stable", "Housing Units", "Treasure", "Bridge"];
                        const bastionType = bastionTypes[rand.nextInt(bastionTypes.length)];
                        if (filters.bastion_type && filters.bastion_type !== "Any" && bastionType !== filters.bastion_type) return null;
                        desc = "Bastion Remnant (" + bastionType + ")";
                    } else if (structure === "Trial Chambers") {
                        const chamberTypes = ["Small", "Medium", "Large"];
                        const chamberType = chamberTypes[rand.nextInt(chamberTypes.length)];
                        desc = "Trial Chambers (" + chamberType + ")";
                    }
                    
                    return [blockX, blockZ, desc, distance];
                }
                
                return null;
            } catch (error) {
                console.error("Error in getStructurePos:", error);
                return null;
            }
        }

        // Enhanced biome distribution analysis
        function analyzeBiomeDistribution(seed, version, radius, dimension) {
            try {
                if (radius === undefined) radius = Constants.WORLD_SETTINGS.BIOME_ANALYSIS_RADIUS;
                if (dimension === undefined) dimension = "overworld";
                
                const biomeCounts = {};
                const step = Math.floor(radius / 100); // More granular sampling
                const points = Array.from({ length: 200 }, (_, i) => -radius + (i * 2 * radius) / 199);
                
                // Sample biome distribution
                for (let i = 0; i < points.length; i++) {
                    const x = Math.floor(points[i]);
                    for (let j = 0; j < points.length; j++) {
                        const z = Math.floor(points[j]);
                        const biomeResult = getBiomeAt(seed, x, z, version, dimension);
                        const biome = biomeResult[0];
                        biomeCounts[biome] = (biomeCounts[biome] || 0) + 1;
                    }
                }
                
                // Calculate percentages
                const total = Object.values(biomeCounts).reduce((sum, count) => sum + count, 0);
                const result = {};
                
                for (const biome in biomeCounts) {
                    result[biome] = (biomeCounts[biome] / total * 100);
                }
                
                return result;
            } catch (error) {
                console.error("Error in analyzeBiomeDistribution:", error);
                return {};
            }
        }

        // Main React App
        function App() {
            const [version, setVersion] = React.useState("1.21");
            const [biomes, setBiomes] = React.useState(["Plains"]);
            const [structures, setStructures] = React.useState([]);
            const [radius, setRadius] = React.useState(500);
            const [priority, setPriority] = React.useState("none");
            const [filters, setFilters] = React.useState({ 
                temple_type: "Any", 
                bastion_type: "Any", 
                stronghold_distance: 0 
            });
            const [currentSeed, setCurrentSeed] = React.useState(null);
            const [positions, setPositions] = React.useState({});
            const [biomeDist, setBiomeDist] = React.useState({});
            const [biomeDistNether, setBiomeDistNether] = React.useState({});
            const [isRunning, setIsRunning] = React.useState(false);
            const [progress, setProgress] = React.useState(0);
            const [attempts, setAttempts] = React.useState(0);
            const [startTime, setStartTime] = React.useState(0);
            const [result, setResult] = React.useState("");
            const [dimension, setDimension] = React.useState("overworld");
            const [zoom, setZoom] = React.useState(1.0);
            const [panOffset, setPanOffset] = React.useState({ x: 0, y: 0 });
            const [isPanning, setIsPanning] = React.useState(false);
            const [panStart, setPanStart] = React.useState({ x: 0, y: 0 });
            const [profiles, setProfiles] = React.useState({});
            const [selectedProfile, setSelectedProfile] = React.useState("");
            const [error, setError] = React.useState("");
            const [showMobileWarning, setShowMobileWarning] = React.useState(false);
            
            const canvasRef = React.useRef(null);
            const workerRef = React.useRef(null);
            const containerRef = React.useRef(null);

            // Load profiles from localStorage with error handling
            React.useEffect(() => {
                try {
                    const savedProfiles = localStorage.getItem("profiles");
                    if (savedProfiles) {
                        setProfiles(JSON.parse(savedProfiles));
                    }
                } catch (e) {
                    console.error("Failed to load profiles:", e);
                    setError("Failed to load saved profiles. Using default settings.");
                }
            }, []);

            // Biome and structure options
            const biomeOptions = Object.keys(Constants.BIOME_WEIGHTS.OVERWORLD).sort();
            const structureOptions = Object.keys(Constants.STRUCTURES)
                .filter(s => !["End City", "Ruined Portal"].includes(s))
                .sort();

            // Initialize Web Worker with enhanced error handling
            React.useEffect(() => {
                // Create worker code as a string
                const workerCode = `
                    ${MinecraftRandom.toString()}
                    ${perlinNoise.toString()}
                    ${getBiomeAt.toString()}
                    ${getStructurePos.toString()}
                    ${analyzeBiomeDistribution.toString()}
                    self.Constants = ${JSON.stringify(Constants)};
                    self.spacing = ${JSON.stringify(spacing)};
                    
                    self.onmessage = function(e) {
                        const data = e.data;
                        const { version, biomes, structures, radius, filters, maxAttempts, priority } = data;
                        let attempts = 0;
                        
                        // Enhanced seed generation with better randomness
                        while (attempts < maxAttempts) {
                            let seed;
                            try {
                                // Try crypto first for better randomness
                                if (self.crypto && self.crypto.getRandomValues) {
                                    const array = new BigUint64Array(1);
                                    self.crypto.getRandomValues(array);
                                    seed = array[0];
                                } else {
                                    // Fallback to Math.random with better distribution
                                    const randomValue = Math.abs(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER * 2) - Number.MAX_SAFE_INTEGER);
                                    seed = BigInt(randomValue);
                                }
                            } catch (e) {
                                // Fallback to simple random with seed variation
                                seed = BigInt(Math.floor(Math.random() * 9007199254740991) + Date.now());
                            }
                            
                            // Validate seed
                            if (seed === undefined || seed === null) {
                                attempts++;
                                continue;
                            }
                            
                            // Check biomes at spawn points
                            let biomeValid = true;
                            const spawnRadius = ${Constants.WORLD_SETTINGS.SPAWN_CHECK_RADIUS};
                            const spawnPoints = [];
                            
                            // Generate spawn points in a grid pattern
                            for (let x = -spawnRadius; x <= spawnRadius; x += 16) {
                                for (let z = -spawnRadius; z <= spawnRadius; z += 16) {
                                    spawnPoints.push([x, z]);
                                }
                            }
                            
                            for (let i = 0; i < biomes.length; i++) {
                                const biome = biomes[i];
                                let found = false;
                                
                                for (const [x, z] of spawnPoints) {
                                    try {
                                        const biomeResult = getBiomeAt(seed, x, z, version, 'overworld');
                                        if (biomeResult && biomeResult[0] === biome) {
                                            found = true;
                                            break;
                                        }
                                    } catch (e) {
                                        console.error("Biome check error:", e);
                                    }
                                }
                                
                                if (!found) {
                                    biomeValid = false;
                                    break;
                                }
                            }
                            
                            if (!biomeValid) {
                                attempts++;
                                continue;
                            }
                            
                            // Check structures with enhanced validation
                            let structurePositions = {};
                            let valid = true;
                            let totalDistance = 0;
                            
                            for (let i = 0; i < structures.length; i++) {
                                const struct = structures[i];
                                try {
                                    const pos = getStructurePos(seed, struct, version, radius, filters);
                                    if (pos) {
                                        structurePositions[struct] = pos;
                                        totalDistance += pos[3];
                                    } else {
                                        valid = false;
                                        break;
                                    }
                                } catch (e) {
                                    console.error("Structure check error:", e);
                                    valid = false;
                                    break;
                                }
                            }
                            
                            // Check distance priority
                            if (valid && priority === 'distance' && structures.length > 0) {
                                const avgDistance = totalDistance / structures.length;
                                const maxAllowedDistance = radius * 0.3;
                                if (avgDistance > maxAllowedDistance) {
                                    valid = false;
                                }
                            }
                            
                            if (valid) {
                                try {
                                    // Analyze biome distributions
                                    const biomeDist = analyzeBiomeDistribution(seed, version, ${Constants.WORLD_SETTINGS.BIOME_ANALYSIS_RADIUS}, 'overworld');
                                    const biomeDistNether = analyzeBiomeDistribution(seed, version, ${Constants.WORLD_SETTINGS.BIOME_ANALYSIS_RADIUS}, 'nether');
                                    
                                    self.postMessage({
                                        seed: seed.toString(),
                                        status: 'Accepted',
                                        structurePositions: structurePositions,
                                        biomeDist: biomeDist,
                                        biomeDistNether: biomeDistNether,
                                        attempts: attempts
                                    });
                                    return;
                                } catch (e) {
                                    console.error("Analysis error:", e);
                                    valid = false;
                                }
                            }
                            
                            attempts++;
                            
                            // Send progress updates more frequently
                            if (attempts % 25 === 0) {
                                self.postMessage({ 
                                    progress: Math.min((attempts / maxAttempts) * 100, 99.9), 
                                    attempts: attempts 
                                });
                            }
                            
                            // Add small delay to prevent blocking UI
                            if (attempts % 1000 === 0) {
                                setTimeout(() => {}, 0);
                            }
                        }
                        
                        self.postMessage({ status: 'No valid seed found', attempts: attempts });
                    };
                `;
                
                try {
                    // Create blob from worker code
                    const blob = new Blob([workerCode], { type: 'application/javascript' });
                    const workerUrl = URL.createObjectURL(blob);
                    workerRef.current = new Worker(workerUrl);
                    
                    // Set up message handler with enhanced error handling
                    workerRef.current.onmessage = function(e) {
                        const data = e.data;
                        
                        if (data.progress !== undefined) {
                            setProgress(data.progress);
                            setAttempts(data.attempts || 0);
                            return;
                        }
                        
                        if (data.status === "Accepted") {
                            setCurrentSeed(data.seed);
                            setPositions(data.structurePositions);
                            
                            // Convert string seed back to number for display
                            let seedNum = parseInt(data.seed);
                            if (isNaN(seedNum) || seedNum > Number.MAX_SAFE_INTEGER) {
                                seedNum = Number(data.seed.substring(0, 15)); // Truncate for display
                            }
                            
                            setBiomeDist(data.biomeDist || {});
                            setBiomeDistNether(data.biomeDistNether || {});
                            
                            // Format results with enhanced structure information
                            const structureLines = [];
                            for (const key in data.structurePositions) {
                                const pos = data.structurePositions[key];
                                if (pos) {
                                    const x = pos[0], z = pos[1], desc = pos[2], dist = pos[3];
                                    structureLines.push(\`  \${desc} at (\${x}, \${z}) (Distance: \${dist.toFixed(1)})\`);
                                }
                            }
                            
                            // Sort by distance
                            structureLines.sort((a, b) => {
                                const distA = parseFloat(a.match(/Distance: ([\\d.]+)/)[1]);
                                const distB = parseFloat(b.match(/Distance: ([\\d.]+)/)[1]);
                                return distA - distB;
                            });
                            
                            // Format biome distributions
                            const biomeDistLines = Object.entries(data.biomeDist || {})
                                .sort(([,a], [,b]) => b - a)
                                .map(([biome, percent]) => \`  \${biome}: \${percent.toFixed(2)}%\`);
                            
                            const biomeDistNetherLines = Object.entries(data.biomeDistNether || {})
                                .sort(([,a], [,b]) => b - a)
                                .map(([biome, percent]) => \`  \${biome}: \${percent.toFixed(2)}%\`);
                            
                            setResult(\`Seed: \${seedNum}
Biomes: \${biomes.join(", ")}
Version: \${version}
Structures:
\${structureLines.join("\\n")}
Biome Distribution (Overworld, \${Constants.WORLD_SETTINGS.BIOME_ANALYSIS_RADIUS}x\${Constants.WORLD_SETTINGS.BIOME_ANALYSIS_RADIUS} blocks):
\${biomeDistLines.join("\\n")}
Biome Distribution (Nether, \${Constants.WORLD_SETTINGS.BIOME_ANALYSIS_RADIUS}x\${Constants.WORLD_SETTINGS.BIOME_ANALYSIS_RADIUS} blocks):
\${biomeDistNetherLines.join("\\n")}\`);
                            
                            setIsRunning(false);
                        } else if (data.status === "No valid seed found") {
                            setResult("No valid seed found after extensive search. Try adjusting criteria.");
                            setIsRunning(false);
                        }
                    };
                    
                    workerRef.current.onerror = function(error) {
                        console.error("Worker error:", error);
                        setError(\`Worker initialization failed: \${error.message || "Unknown error"}\`);
                        setIsRunning(false);
                    };
                } catch (e) {
                    console.error("Failed to initialize Web Worker:", e);
                    setError(\`Failed to initialize seed generation: \${e.message || "Check browser compatibility"}\`);
                    setIsRunning(false);
                }
                
                // Cleanup function
                return () => {
                    if (workerRef.current) {
                        workerRef.current.terminate();
                    }
                };
            }, [biomes, structures, version, radius, priority, filters]);

            // Draw map on canvas with enhanced rendering
            React.useEffect(() => {
                if (!canvasRef.current || !currentSeed || Object.keys(positions).length === 0) return;
                
                const canvas = canvasRef.current;
                const ctx = canvas.getContext("2d");
                const rect = canvas.getBoundingClientRect();
                const width = rect.width;
                const height = rect.height;
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                
                // Calculate scale and center
                const scale = Math.min(width, height) / (2 * radius) * zoom;
                const centerX = width / 2;
                const centerY = height / 2;
                
                // Biome colors with enhanced palette
                const biomeColors = {
                    "Plains": "#90EE90", "Forest": "#228B22", "Desert": "#EDC9AF", "Taiga": "#2F4F4F",
                    "Swamp": "#6B8E23", "Jungle": "#006400", "Savanna": "#DAA520", "Badlands": "#8B0000",
                    "Mushroom Fields": "#FFE4E1", "Deep Dark": "#1C2526", "Mangrove Swamp": "#3CB371",
                    "Cherry Grove": "#FF69B4", "Lush Caves": "#00CED1", "Snowy Plains": "#F0F8FF",
                    "Ocean": "#1E90FF", "Meadow": "#98FB98", "Bamboo Jungle": "#9ACD32",
                    "Nether Wastes": "#8B0000", "Crimson Forest": "#DC143C", "Warped Forest": "#20B2AA",
                    "Soul Sand Valley": "#B0C4DE", "Basalt Deltas": "#696969", "Giant Tree Taiga": "#3A5F0B",
                    "Stone Shore": "#808080", "River": "#4682B4", "Beach": "#F5DEB3", "Dark Forest": "#191970"
                };
                
                // Structure colors with enhanced visibility
                const structureColors = {
                    "Village": "#FFD700", "Mineshaft": "#808080", "Stronghold": "#800080", "Temple": "#FFA500",
                    "Monument": "#0000FF", "Mansion": "#8B4513", "Bastion Remnant": "#000000", "Ancient City": "#00FFFF",
                    "Nether Fortress": "#FF0000", "Trial Chambers": "#FF00FF", "Ruined Portal": "#A52A2A"
                };
                
                // Draw biome grid with optimized rendering
                const analysisRadius = Constants.WORLD_SETTINGS.BIOME_ANALYSIS_RADIUS;
                const step = Math.floor(analysisRadius / 80);
                
                // Only draw visible portion
                const visibleMinX = -width/(2*scale) - panOffset.x/scale;
                const visibleMaxX = width/(2*scale) - panOffset.x/scale;
                const visibleMinZ = -height/(2*scale) - panOffset.y/scale;
                const visibleMaxZ = height/(2*scale) - panOffset.y/scale;
                
                for (let x = Math.max(-analysisRadius, visibleMinX - step); x <= Math.min(analysisRadius, visibleMaxX + step); x += step) {
                    for (let z = Math.max(-analysisRadius, visibleMinZ - step); z <= Math.min(analysisRadius, visibleMaxZ + step); z += step) {
                        try {
                            const biomeResult = getBiomeAt(BigInt(currentSeed), x, z, version, dimension);
                            const biome = biomeResult[0];
                            const color = biomeColors[biome] || "#2b2b2b";
                            
                            const screenX = centerX + (x * scale) + panOffset.x;
                            const screenY = centerY + (z * scale) + panOffset.y;
                            
                            // Only draw if visible
                            if (screenX > -step * scale && screenX < width + step * scale &&
                                screenY > -step * scale && screenY < height + step * scale) {
                                ctx.fillStyle = color;
                                ctx.globalAlpha = 0.5;
                                ctx.fillRect(screenX - step * scale / 2, screenY - step * scale / 2, 
                                           step * scale, step * scale);
                                ctx.globalAlpha = 1.0;
                            }
                        } catch (e) {
                            console.error("Biome rendering error:", e);
                        }
                    }
                }
                
                // Draw spawn point
                if (dimension === "overworld") {
                    ctx.fillStyle = "red";
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 6, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.strokeStyle = "black";
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.lineWidth = 1;
                }
                
                // Draw structures with enhanced visibility
                for (const struct in positions) {
                    const pos = positions[struct];
                    if (!pos) continue;
                    
                    const x = pos[0], z = pos[1], desc = pos[2];
                    
                    // Skip structures not in current dimension
                    if (dimension === "nether" && !["Bastion Remnant", "Nether Fortress"].includes(struct)) continue;
                    if (dimension === "overworld" && ["Bastion Remnant", "Nether Fortress"].includes(struct)) continue;
                    
                    const screenX = centerX + (x * scale) + panOffset.x;
                    const screenY = centerY + (z * scale) + panOffset.y;
                    
                    // Only draw if visible
                    if (screenX > -20 && screenX < width + 20 && screenY > -20 && screenY < height + 20) {
                        const color = structureColors[struct] || "white";
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, 6, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.strokeStyle = "black";
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        ctx.lineWidth = 1;
                        
                        // Label with enhanced readability
                        ctx.fillStyle = "#e0e0e0";
                        ctx.font = "12px Arial";
                        ctx.textAlign = "left";
                        ctx.fillText(desc, screenX + 10, screenY + 4);
                        ctx.textAlign = "start";
                    }
                }
            }, [currentSeed, positions, version, dimension, zoom, panOffset, radius]);

            // Find valid seed with enhanced validation
            const findValidSeed = React.useCallback(() => {
                // Mobile warning
                if (window.innerWidth < 768) {
                    setShowMobileWarning(true);
                    setTimeout(() => setShowMobileWarning(false), 3000);
                }
                
                if (isRunning) return;
                
                // Validate inputs with enhanced error checking
                if (!biomes || biomes.length === 0) {
                    setError("Please select at least one biome.");
                    return;
                }
                
                if (!structures || structures.length === 0) {
                    setError("Please select at least one structure.");
                    return;
                }
                
                if (radius < 100 || radius > 4000) {
                    setError("Radius must be between 100 and 4000 blocks.");
                    return;
                }
                
                setIsRunning(true);
                setProgress(0);
                setAttempts(0);
                setStartTime(Date.now());
                setResult("Generating seed, please wait...");
                setError("");
                
                if (workerRef.current) {
                    workerRef.current.postMessage({
                        version,
                        biomes,
                        structures,
                        radius,
                        filters,
                        priority,
                        maxAttempts: Constants.WORLD_SETTINGS.SEARCH_ITERATIONS
                    });
                } else {
                    setError("Web Worker not initialized. Please refresh the page.");
                    setIsRunning(false);
                }
            }, [isRunning, biomes, structures, version, radius, filters, priority]);

            // Stop search with proper cleanup
            const stopSearch = React.useCallback(() => {
                if (workerRef.current) {
                    workerRef.current.terminate();
                    // Recreate worker with fresh instance
                    const workerCode = `
                        ${MinecraftRandom.toString()}
                        ${perlinNoise.toString()}
                        ${getBiomeAt.toString()}
                        ${getStructurePos.toString()}
                        ${analyzeBiomeDistribution.toString()}
                        self.Constants = ${JSON.stringify(Constants)};
                        self.spacing = ${JSON.stringify(spacing)};
                        
                        self.onmessage = function(e) {
                            const data = e.data;
                            const { version, biomes, structures, radius, filters, maxAttempts, priority } = data;
                            let attempts = 0;
                            
                            while (attempts < maxAttempts) {
                                let seed;
                                try {
                                    if (self.crypto && self.crypto.getRandomValues) {
                                        const array = new BigUint64Array(1);
                                        self.crypto.getRandomValues(array);
                                        seed = array[0];
                                    } else {
                                        const randomValue = Math.abs(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER * 2) - Number.MAX_SAFE_INTEGER);
                                        seed = BigInt(randomValue);
                                    }
                                } catch (e) {
                                    seed = BigInt(Math.floor(Math.random() * 9007199254740991) + Date.now());
                                }
                                
                                let biomeValid = true;
                                const spawnRadius = ${Constants.WORLD_SETTINGS.SPAWN_CHECK_RADIUS};
                                const spawnPoints = [];
                                
                                for (let x = -spawnRadius; x <= spawnRadius; x += 16) {
                                    for (let z = -spawnRadius; z <= spawnRadius; z += 16) {
                                        spawnPoints.push([x, z]);
                                    }
                                }
                                
                                for (let i = 0; i < biomes.length; i++) {
                                    const biome = biomes[i];
                                    let found = false;
                                    
                                    for (const [x, z] of spawnPoints) {
                                        const biomeResult = getBiomeAt(seed, x, z, version, 'overworld');
                                        if (biomeResult && biomeResult[0] === biome) {
                                            found = true;
                                            break;
                                        }
                                    }
                                    
                                    if (!found) {
                                        biomeValid = false;
                                        break;
                                    }
                                }
                                
                                if (!biomeValid) {
                                    attempts++;
                                    continue;
                                }
                                
                                let structurePositions = {};
                                let valid = true;
                                let totalDistance = 0;
                                
                                for (let i = 0; i < structures.length; i++) {
                                    const struct = structures[i];
                                    const pos = getStructurePos(seed, struct, version, radius, filters);
                                    if (pos) {
                                        structurePositions[struct] = pos;
                                        totalDistance += pos[3];
                                    } else {
                                        valid = false;
                                        break;
                                    }
                                }
                                
                                if (valid && priority === 'distance' && structures.length > 0) {
                                    const avgDistance = totalDistance / structures.length;
                                    const maxAllowedDistance = radius * 0.3;
                                    if (avgDistance > maxAllowedDistance) {
                                        valid = false;
                                    }
                                }
                                
                                if (valid) {
                                    const biomeDist = analyzeBiomeDistribution(seed, version, ${Constants.WORLD_SETTINGS.BIOME_ANALYSIS_RADIUS}, 'overworld');
                                    const biomeDistNether = analyzeBiomeDistribution(seed, version, ${Constants.WORLD_SETTINGS.BIOME_ANALYSIS_RADIUS}, 'nether');
                                    
                                    self.postMessage({
                                        seed: seed.toString(),
                                        status: 'Accepted',
                                        structurePositions: structurePositions,
                                        biomeDist: biomeDist,
                                        biomeDistNether: biomeDistNether,
                                        attempts: attempts
                                    });
                                    return;
                                }
                                
                                attempts++;
                                
                                if (attempts % 25 === 0) {
                                    self.postMessage({ 
                                        progress: Math.min((attempts / maxAttempts) * 100, 99.9), 
                                        attempts: attempts 
                                    });
                                }
                            }
                            
                            self.postMessage({ status: 'No valid seed found', attempts: attempts });
                        };
                    `;
                    
                    const blob = new Blob([workerCode], { type: 'application/javascript' });
                    const workerUrl = URL.createObjectURL(blob);
                    workerRef.current = new Worker(workerUrl);
                    
                    workerRef.current.onmessage = function(e) {
                        const data = e.data;
                        
                        if (data.progress !== undefined) {
                            setProgress(data.progress);
                            setAttempts(data.attempts || 0);
                            return;
                        }
                        
                        if (data.status === "Accepted") {
                            setCurrentSeed(data.seed);
                            setPositions(data.structurePositions);
                            
                            let seedNum = parseInt(data.seed);
                            if (isNaN(seedNum) || seedNum > Number.MAX_SAFE_INTEGER) {
                                seedNum = Number(data.seed.substring(0, 15));
                            }
                            
                            setBiomeDist(data.biomeDist || {});
                            setBiomeDistNether(data.biomeDistNether || {});
                            
                            const structureLines = [];
                            for (const key in data.structurePositions) {
                                const pos = data.structurePositions[key];
                                if (pos) {
                                    const x = pos[0], z = pos[1], desc = pos[2], dist = pos[3];
                                    structureLines.push(\`  \${desc} at (\${x}, \${z}) (Distance: \${dist.toFixed(1)})\`);
                                }
                            }
                            
                            structureLines.sort((a, b) => {
                                const distA = parseFloat(a.match(/Distance: ([\\d.]+)/)[1]);
                                const distB = parseFloat(b.match(/Distance: ([\\d.]+)/)[1]);
                                return distA - distB;
                            });
                            
                            const biomeDistLines = Object.entries(data.biomeDist || {})
                                .sort(([,a], [,b]) => b - a)
                                .map(([biome, percent]) => \`  \${biome}: \${percent.toFixed(2)}%\`);
                            
                            const biomeDistNetherLines = Object.entries(data.biomeDistNether || {})
                                .sort(([,a], [,b]) => b - a)
                                .map(([biome, percent]) => \`  \${biome}: \${percent.toFixed(2)}%\`);
                            
                            setResult(\`Seed: \${seedNum}
Biomes: \${biomes.join(", ")}
Version: \${version}
Structures:
\${structureLines.join("\\n")}
Biome Distribution (Overworld, \${Constants.WORLD_SETTINGS.BIOME_ANALYSIS_RADIUS}x\${Constants.WORLD_SETTINGS.BIOME_ANALYSIS_RADIUS} blocks):
\${biomeDistLines.join("\\n")}
Biome Distribution (Nether, \${Constants.WORLD_SETTINGS.BIOME_ANALYSIS_RADIUS}x\${Constants.WORLD_SETTINGS.BIOME_ANALYSIS_RADIUS} blocks):
\${biomeDistNetherLines.join("\\n")}\`);
                            
                            setIsRunning(false);
                        } else if (data.status === "No valid seed found") {
                            setResult("No valid seed found after extensive search. Try adjusting criteria.");
                            setIsRunning(false);
                        }
                    };
                }
                
                setIsRunning(false);
                setResult("Search stopped by user.");
            }, [biomes, structures, version, radius, filters, priority]);

            // Handle biome addition with enhanced validation
            const addBiome = (biome) => {
                if (biomes.length < 3 && !biomes.includes(biome)) {
                    setBiomes([...biomes, biome]);
                    setError("");
                } else if (biomes.length >= 3) {
                    setError("Maximum 3 biomes allowed!");
                }
            };

            // Handle structure toggle with enhanced validation
            const toggleStructure = (struct) => {
                if (structures.includes(struct)) {
                    setStructures(structures.filter(s => s !== struct));
                    setError("");
                } else if (structures.length < 3) {
                    setStructures([...structures, struct]);
                    setError("");
                } else {
                    setError("Maximum 3 structures allowed!");
                }
            };

            // Save profile with enhanced error handling
            const saveProfile = () => {
                const name = prompt("Enter profile name:");
                if (name && name.trim() !== "") {
                    try {
                        const profile = { version, biomes, structures, radius, priority, filters };
                        const newProfiles = { ...profiles, [name.trim()]: profile };
                        setProfiles(newProfiles);
                        localStorage.setItem("profiles", JSON.stringify(newProfiles));
                        setSelectedProfile(name.trim());
                        setError("");
                    } catch (e) {
                        setError("Failed to save profile! Check browser storage permissions.");
                    }
                } else if (name !== null) {
                    setError("Profile name cannot be empty!");
                }
            };

            // Load profile with enhanced validation
            const loadProfile = (name) => {
                if (name && profiles[name]) {
                    const profile = profiles[name];
                    // Validate profile data
                    if (profile && Array.isArray(profile.biomes) && Array.isArray(profile.structures)) {
                        setVersion(profile.version || "1.21");
                        setBiomes(profile.biomes);
                        setStructures(profile.structures);
                        setRadius(profile.radius || 500);
                        setPriority(profile.priority || "none");
                        setFilters(profile.filters || { temple_type: "Any", bastion_type: "Any", stronghold_distance: 0 });
                        setSelectedProfile(name);
                        setError("");
                    } else {
                        setError("Invalid profile data!");
                    }
                }
            };

            // Delete profile with confirmation
            const deleteProfile = () => {
                if (selectedProfile) {
                    if (window.confirm(`Are you sure you want to delete profile "${selectedProfile}"?`)) {
                        try {
                            const newProfiles = { ...profiles };
                            delete newProfiles[selectedProfile];
                            setProfiles(newProfiles);
                            localStorage.setItem("profiles", JSON.stringify(newProfiles));
                            setSelectedProfile("");
                            setError("");
                        } catch (e) {
                            setError("Failed to delete profile!");
                        }
                    }
                }
            };

            // Export results with enhanced formatting
            const exportResults = () => {
                if (!currentSeed) {
                    setError("No seed to export!");
                    return;
                }
                try {
                    const resultData = {
                        seed: currentSeed,
                        biomes,
                        structures: positions,
                        radius,
                        version,
                        biome_distribution_overworld: biomeDist,
                        biome_distribution_nether: biomeDistNether,
                        timestamp: new Date().toISOString(),
                        criteria: { priority, ...filters },
                        application: "Minecraft Seed Generator Ultimate",
                        version: "2.0"
                    };
                    const blob = new Blob([JSON.stringify(resultData, null, 2)], { type: "application/json" });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement("a");
                    a.href = url;
                    a.download = `minecraft_seed_${Date.now()}.json`;
                    a.click();
                    URL.revokeObjectURL(url);
                    setError("");
                } catch (e) {
                    setError("Failed to export results! " + (e.message || "Unknown error"));
                }
            };

            // Copy seed with enhanced feedback
            const copySeed = () => {
                if (currentSeed) {
                    try {
                        const seedNum = parseInt(currentSeed);
                        if (!isNaN(seedNum)) {
                            navigator.clipboard.writeText(seedNum.toString()).then(() => {
                                alert("Seed copied to clipboard successfully!");
                            }).catch(err => {
                                setError("Failed to copy seed: " + (err.message || "Permission denied"));
                            });
                        } else {
                            setError("Invalid seed format!");
                        }
                    } catch (e) {
                        setError("Failed to copy seed!");
                    }
                } else {
                    setError("No seed to copy!");
                }
            };

            // Handle canvas interactions with touch support
            const handlePanStart = (e) => {
                setIsPanning(true);
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                setPanStart({ x: clientX, y: clientY });
            };

            const handlePanMove = (e) => {
                if (!isPanning) return;
                e.preventDefault();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                setPanOffset({
                    x: panOffset.x + (clientX - panStart.x),
                    y: panOffset.y + (clientY - panStart.y)
                });
                setPanStart({ x: clientX, y: clientY });
            };

            const handlePanEnd = () => {
                setIsPanning(false);
            };

            // Reset settings with confirmation
            const resetSettings = () => {
                if (window.confirm("Are you sure you want to reset all settings to default?")) {
                    setVersion("1.21");
                    setBiomes(["Plains"]);
                    setStructures([]);
                    setRadius(500);
                    setPriority("none");
                    setFilters({ temple_type: "Any", bastion_type: "Any", stronghold_distance: 0 });
                    setSelectedProfile("");
                    setError("");
                    setCurrentSeed(null);
                    setPositions({});
                    setBiomeDist({});
                    setBiomeDistNether({});
                    setResult("");
                    setZoom(1.0);
                    setPanOffset({ x: 0, y: 0 });
                }
            };

            // Format time elapsed with enhanced precision
            const formatTime = () => {
                if (!startTime) return "0.0";
                return ((Date.now() - startTime) / 1000).toFixed(1);
            };

            return (
                <div className="container">
                    {/* Control Panel */}
                    <div className="control-panel">
                        <div className="panel">
                            <h1 className="text-lg font-bold text-green-400 mb-4">Minecraft Seed Generator</h1>
                            
                            {error && (
                                <div className="error-message">
                                    {error}
                                </div>
                            )}
                            
                            {showMobileWarning && (
                                <div className="error-message bg-yellow-900 text-yellow-200">
                                    Note: Seed generation may be slower on mobile devices.
                                </div>
                            )}
                            
                            {/* Version Selection */}
                            <div className="mb-4">
                                <label className="block text-sm mb-2">Minecraft Version:</label>
                                <select 
                                    value={version} 
                                    onChange={(e) => setVersion(e.target.value)}
                                    className="input"
                                >
                                    {["1.14", "1.15", "1.16", "1.17", "1.18", "1.19", "1.20", "1.21"].map(v => (
                                        <option key={v} value={v}>{v}</option>
                                    ))}
                                </select>
                            </div>
                            
                            {/* Biome Selection */}
                            <div className="mb-4">
                                <label className="block text-sm mb-2">Spawn Biomes (up to 3):</label>
                                {biomes.map((b, i) => (
                                    <select 
                                        key={i} 
                                        value={b} 
                                        onChange={(e) => {
                                            const newBiomes = [...biomes];
                                            newBiomes[i] = e.target.value;
                                            setBiomes(newBiomes);
                                        }}
                                        className="input mb-2"
                                    >
                                        {biomeOptions.map(o => (
                                            <option key={o} value={o}>{o}</option>
                                        ))}
                                    </select>
                                ))}
                                <button 
                                    onClick={() => addBiome(biomeOptions[0])}
                                    className="btn btn-success w-full mt-2"
                                >
                                    Add Biome
                                </button>
                            </div>
                            
                            {/* Structure Selection */}
                            <div className="mb-4">
                                <label className="block text-sm mb-2">Structures (up to 3):</label>
                                <div className="grid grid-cols-2 gap-2">
                                    {structureOptions.map(s => (
                                        <label key={s} className="flex items-center">
                                            <input 
                                                type="checkbox"
                                                checked={structures.includes(s)}
                                                onChange={() => toggleStructure(s)}
                                                className="mr-2"
                                            />
                                            {s}
                                        </label>
                                    ))}
                                </div>
                            </div>
                            
                            {/* Structure Filters */}
                            <div className="mb-4">
                                <label className="block text-sm mb-2">Structure Filters:</label>
                                <div className="space-y-2">
                                    <div>
                                        <label className="block text-xs mb-1">Temple Type:</label>
                                        <select 
                                            value={filters.temple_type}
                                            onChange={(e) => setFilters({...filters, temple_type: e.target.value})}
                                            className="input"
                                        >
                                            {["Any", "Desert", "Jungle", "Swamp", "Igloo"].map(t => (
                                                <option key={t} value={t}>{t}</option>
                                            ))}
                                        </select>
                                    </div>
                                    <div>
                                        <label className="block text-xs mb-1">Bastion Type:</label>
                                        <select 
                                            value={filters.bastion_type}
                                            onChange={(e) => setFilters({...filters, bastion_type: e.target.value})}
                                            className="input"
                                        >
                                            {["Any", "Hoglin Stable", "Housing Units", "Treasure", "Bridge"].map(t => (
                                                <option key={t} value={t}>{t}</option>
                                            ))}
                                        </select>
                                    </div>
                                    <div>
                                        <label className="block text-xs mb-1">Max Stronghold Distance:</label>
                                        <input 
                                            type="number"
                                            value={filters.stronghold_distance}
                                            onChange={(e) => setFilters({...filters, stronghold_distance: parseFloat(e.target.value) || 0})}
                                            className="input"
                                            min="0"
                                            max="4000"
                                        />
                                    </div>
                                </div>
                            </div>
                            
                            {/* Priority Selection */}
                            <div className="mb-4">
                                <label className="block text-sm mb-2">Priority:</label>
                                <div className="space-y-2">
                                    <label className="flex items-center">
                                        <input 
                                            type="radio"
                                            name="priority"
                                            value="none"
                                            checked={priority === "none"}
                                            onChange={(e) => setPriority(e.target.value)}
                                            className="mr-2"
                                        />
                                        None
                                    </label>
                                    <label className="flex items-center">
                                        <input 
                                            type="radio"
                                            name="priority"
                                            value="distance"
                                            checked={priority === "distance"}
                                            onChange={(e) => setPriority(e.target.value)}
                                            className="mr-2"
                                        />
                                        Closer Structures
                                    </label>
                                </div>
                            </div>
                            
                            {/* Radius Slider */}
                            <div className="mb-4">
                                <label className="block text-sm mb-2">Search Radius (blocks): {radius}</label>
                                <input 
                                    type="range"
                                    min="100"
                                    max="4000"
                                    value={radius}
                                    onChange={(e) => setRadius(parseInt(e.target.value))}
                                    className="input-range"
                                />
                                <div className="flex justify-between text-xs text-gray-400">
                                    <span>100</span>
                                    <span>4000</span>
                                </div>
                            </div>
                            
                            {/* Profile Management */}
                            <div className="mb-4">
                                <label className="block text-sm mb-2">Saved Profiles:</label>
                                <select 
                                    value={selectedProfile}
                                    onChange={(e) => loadProfile(e.target.value)}
                                    className="input mb-2"
                                >
                                    <option value="">Select Profile</option>
                                    {Object.keys(profiles).map(p => (
                                        <option key={p} value={p}>{p}</option>
                                    ))}
                                </select>
                                <div className="flex gap-2">
                                    <button 
                                        onClick={saveProfile}
                                        className="btn btn-secondary flex-1"
                                    >
                                        Save Profile
                                    </button>
                                    <button 
                                        onClick={deleteProfile}
                                        className="btn btn-danger flex-1"
                                    >
                                        Delete
                                    </button>
                                </div>
                            </div>
                            
                            {/* Controls */}
                            <div className="mb-4 space-y-2">
                                <button 
                                    onClick={findValidSeed}
                                    disabled={isRunning}
                                    className={`btn btn-primary w-full ${isRunning ? 'opacity-75' : ''}`}
                                >
                                    {isRunning ? 'Generating...' : 'Generate Seed'}
                                </button>
                                <button 
                                    onClick={stopSearch}
                                    disabled={!isRunning}
                                    className={`btn btn-danger w-full ${!isRunning ? 'opacity-75' : ''}`}
                                >
                                    Stop Search
                                </button>
                                <button 
                                    onClick={exportResults}
                                    disabled={!currentSeed}
                                    className={`btn btn-secondary w-full ${!currentSeed ? 'opacity-75' : ''}`}
                                >
                                    Export Results
                                </button>
                                <button 
                                    onClick={copySeed}
                                    disabled={!currentSeed}
                                    className={`btn btn-warning w-full ${!currentSeed ? 'opacity-75' : ''}`}
                                >
                                    Copy Seed
                                </button>
                                <button 
                                    onClick={resetSettings}
                                    className="btn btn-success w-full"
                                >
                                    Reset Settings
                                </button>
                            </div>
                            
                            {/* Progress and Stats */}
                            <div className="mb-4">
                                <div className="progress-container">
                                    <div className="progress-bar" style={{width: \`\${progress}%\`}}></div>
                                </div>
                                <div className="flex justify-between text-sm">
                                    <span>Attempts: {attempts}</span>
                                    <span>Time: {formatTime()}s</span>
                                </div>
                            </div>
                            
                            {/* Result Display */}
                            <textarea 
                                value={result}
                                readOnly
                                className="result-textarea"
                                placeholder="Generated seed results will appear here..."
                            ></textarea>
                        </div>
                    </div>
                    
                    {/* Map Panel */}
                    <div className="map-panel">
                        <h2 className="text-lg font-bold text-green-400 mb-4">Map Preview</h2>
                        
                        <div className="flex gap-4 mb-4">
                            <label className="flex items-center">
                                <input 
                                    type="radio"
                                    name="dimension"
                                    value="overworld"
                                    checked={dimension === "overworld"}
                                    onChange={(e) => setDimension(e.target.value)}
                                    className="mr-2"
                                />
                                Overworld
                            </label>
                            <label className="flex items-center">
                                <input 
                                    type="radio"
                                    name="dimension"
                                    value="nether"
                                    checked={dimension === "nether"}
                                    onChange={(e) => setDimension(e.target.value)}
                                    className="mr-2"
                                />
                                Nether
                            </label>
                        </div>
                        
                        <div className="canvas-container">
                            <canvas
                                ref={canvasRef}
                                onMouseDown={handlePanStart}
                                onMouseMove={handlePanMove}
                                onMouseUp={handlePanEnd}
                                onMouseLeave={handlePanEnd}
                                onTouchStart={handlePanStart}
                                onTouchMove={handlePanMove}
                                onTouchEnd={handlePanEnd}
                            ></canvas>
                        </div>
                        
                        <div className="mt-4 w-full">
                            <label className="block text-sm mb-2">Zoom: {zoom.toFixed(1)}x</label>
                            <input 
                                type="range"
                                min="0.5"
                                max="4.0"
                                step="0.1"
                                value={zoom}
                                onChange={(e) => setZoom(parseFloat(e.target.value))}
                                className="input-range"
                            />
                        </div>
                    </div>
                </div>
            );
        }
        
        // Render App
        const root = ReactDOM.createRoot(document.getElementById("root"));
        root.render(React.createElement(App));
    </script>
</body>
</html>
```
