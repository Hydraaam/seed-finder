<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minecraft Seed Generator Ultimate</title>
    <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <style>
        body { 
            background-color: #1a1a1a; 
            color: #e0e0e0; 
            font-family: 'Arial', sans-serif; 
            margin: 0; 
            padding: 0; 
            overflow-x: hidden;
        }
        .scrollbar-custom::-webkit-scrollbar { width: 8px; }
        .scrollbar-custom::-webkit-scrollbar-track { background: #2b2b2b; }
        .scrollbar-custom::-webkit-scrollbar-thumb { background: #4caf50; border-radius: 4px; }
        .scrollbar-custom::-webkit-scrollbar-thumb:hover { background: #66bb6a; }
        .container { 
            display: flex; 
            flex-direction: column; 
            min-height: 100vh; 
            width: 100%;
        }
        @media (min-width: 768px) {
            .container { 
                flex-direction: row; 
            }
        }
        .panel { 
            padding: 1rem; 
        }
        .control-panel { 
            width: 100%; 
            background-color: #1f2937; 
            order: 2; 
        }
        @media (min-width: 768px) {
            .control-panel { 
                width: 24rem; 
                order: 1; 
                max-height: 100vh; 
                overflow-y: auto; 
            }
        }
        .map-panel { 
            flex: 1; 
            padding: 1rem; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            order: 1; 
        }
        @media (min-width: 768px) {
            .map-panel { 
                order: 2; 
                padding: 1.5rem; 
            }
        }
        .canvas-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            aspect-ratio: 4 / 3;
            margin: 0 auto;
        }
        canvas {
            border: 2px solid #374151;
            border-radius: 0.5rem;
            background-color: #111827;
            width: 100%;
            height: 100%;
            display: block;
        }
        .btn {
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            border: none;
            font-weight: 500;
            transition: all 0.2s;
            cursor: pointer;
            text-align: center;
            width: 100%;
        }
        .btn-primary { background-color: #10b981; color: white; }
        .btn-primary:hover { background-color: #0d9488; }
        .btn-primary:disabled { background-color: #6b7280; cursor: not-allowed; }
        .btn-secondary { background-color: #3b82f6; color: white; }
        .btn-secondary:hover { background-color: #2563eb; }
        .btn-danger { background-color: #ef4444; color: white; }
        .btn-danger:hover { background-color: #dc2626; }
        .btn-warning { background-color: #f59e0b; color: white; }
        .btn-warning:hover { background-color: #d97706; }
        .btn-success { background-color: #10b981; color: white; }
        .btn-success:hover { background-color: #0d9488; }
        .input, select {
            width: 100%;
            padding: 0.5rem;
            border-radius: 0.375rem;
            border: 1px solid #4b5563;
            background-color: #374151;
            color: white;
            margin-bottom: 0.5rem;
        }
        .input-range {
            width: 100%;
            margin-bottom: 0.5rem;
        }
        .error-message {
            color: #ef4444;
            font-size: 0.875rem;
            margin-bottom: 1rem;
            padding: 0.5rem;
            background-color: #3f1717;
            border-radius: 0.375rem;
        }
        .progress-container {
            width: 100%;
            height: 0.5rem;
            background-color: #374151;
            border-radius: 999px;
            margin-bottom: 0.5rem;
            overflow: hidden;
        }
        .progress-bar {
            height: 100%;
            background-color: #10b981;
            border-radius: 999px;
            transition: width 0.2s;
        }
        .result-textarea {
            width: 100%;
            min-height: 120px;
            background-color: #374151;
            color: white;
            border-radius: 0.375rem;
            padding: 0.5rem;
            resize: vertical;
            font-family: monospace;
            font-size: 0.875rem;
        }
        .flex {
            display: flex;
        }
        .flex-col {
            flex-direction: column;
        }
        .flex-row {
            flex-direction: row;
        }
        .gap-2 {
            gap: 0.5rem;
        }
        .gap-4 {
            gap: 1rem;
        }
        .mb-2 {
            margin-bottom: 0.5rem;
        }
        .mb-4 {
            margin-bottom: 1rem;
        }
        .mt-4 {
            margin-top: 1rem;
        }
        .text-sm {
            font-size: 0.875rem;
        }
        .text-lg {
            font-size: 1.125rem;
        }
        .font-bold {
            font-weight: 700;
        }
        .text-green-400 {
            color: #10b981;
        }
        .grid {
            display: grid;
        }
        .grid-cols-1 {
            grid-template-columns: repeat(1, 1fr);
        }
        .grid-cols-2 {
            grid-template-columns: repeat(2, 1fr);
        }
        .items-center {
            align-items: center;
        }
        .justify-between {
            justify-content: space-between;
        }
        .mobile-warning {
            background-color: #7c2d12;
            color: #fed7aa;
            padding: 0.5rem;
            border-radius: 0.375rem;
            margin-bottom: 1rem;
            font-size: 0.875rem;
            text-align: center;
        }
        @media (max-width: 767px) {
            .mobile-header {
                text-align: center;
                margin-bottom: 1rem;
            }
            .mobile-controls {
                flex-direction: column;
                gap: 0.5rem;
            }
            .canvas-container {
                aspect-ratio: 4 / 3;
            }
            .result-textarea {
                min-height: 80px;
                font-size: 0.75rem;
            }
            .panel {
                padding: 0.5rem;
            }
        }
    </style>
</head>
<body>
    <div id="root" class="w-full"></div>
    <script type="text/babel">
        // Constants
        const Constants = {
            STRUCTURES: {
                Village: { spacing: 32, minDist: 8, weight: 1.0, yRange: [-64, 319], types: ["Plains", "Desert", "Savanna", "Snowy", "Taiga", "Meadow"] },
                Mineshaft: { spacing: 1, minDist: 1, weight: 0.8, yRange: [-64, 30], types: ["Normal", "Mesa"] },
                Stronghold: { spacing: 16, minDist: 1, weight: 1.0, yRange: [-64, 30], special: true },
                Temple: { spacing: 32, minDist: 8, weight: 0.9, yRange: [-64, 319], types: ["Desert", "Jungle", "Swamp", "Igloo"] },
                Monument: { spacing: 32, minDist: 5, weight: 0.7, yRange: [0, 63], underwater: true },
                Mansion: { spacing: 80, minDist: 20, weight: 0.5, yRange: [60, 319], exclusive: true },
                "Bastion Remnant": { spacing: 27, minDist: 10, weight: 0.8, yRange: [0, 128], types: ["Bridge", "Hoglin Stable", "Housing Units", "Treasure"] },
                "Ancient City": { spacing: 24, minDist: 8, weight: 0.7, yRange: [-64, 0], deepslate: true },
                "Nether Fortress": { spacing: 16, minDist: 5, weight: 0.9, yRange: [0, 128], nether: true },
                "Trial Chambers": { spacing: 32, minDist: 8, weight: 0.6, yRange: [-64, 30], types: ["Small", "Medium", "Large"] },
                "End City": { spacing: 20, minDist: 11, weight: 0.8, yRange: [0, 256], end: true },
                "Ruined Portal": { spacing: 25, minDist: 8, weight: 0.9, yRange: [-64, 319], types: ["Standard", "Giant"] }
            },
            BIOME_WEIGHTS: {
                OVERWORLD: {
                    Plains: 0.35, Forest: 0.25, Desert: 0.15, Taiga: 0.15, Swamp: 0.10,
                    Jungle: 0.05, Savanna: 0.12, Badlands: 0.05, "Mushroom Fields": 0.005,
                    "Deep Dark": 0.04, "Mangrove Swamp": 0.05, "Cherry Grove": 0.03,
                    "Lush Caves": 0.04, "Snowy Plains": 0.08, Ocean: 0.25,
                    Meadow: 0.05, "Bamboo Jungle": 0.02, "Frozen Ocean": 0.08,
                    "Birch Forest": 0.12, "Dark Forest": 0.08, "Giant Tree Taiga": 0.06,
                    "Stone Shore": 0.03, "River": 0.15, "Beach": 0.05
                },
                NETHER: {
                    "Nether Wastes": 0.30, "Crimson Forest": 0.25, "Warped Forest": 0.25,
                    "Soul Sand Valley": 0.15, "Basalt Deltas": 0.05
                },
                END: {
                    "End Highlands": 0.40, "End Midlands": 0.30, "End Barrens": 0.20,
                    "Small End Islands": 0.10
                }
            },
            WORLD_SETTINGS: {
                CHUNK_SIZE: 16,
                MAX_HEIGHT: 319,
                MIN_HEIGHT: -64,
                SEARCH_ITERATIONS: 50000,
                STRUCTURE_REGION_BITS: 12,
                MAX_CACHED_RESULTS: 1000,
                NOISE_OCTAVES: 8,
                NOISE_PERSISTENCE: 0.5,
                NOISE_SCALE: 0.007,
                BIOME_ANALYSIS_RADIUS: 4000,
                SPAWN_CHECK_RADIUS: 32
            },
            LOOT_TABLES: {
                Village: ["iron", "food", "emeralds", "tools", "armor"],
                Temple: ["gold", "diamonds", "emeralds", "potions", "enchanted_books"],
                Monument: ["gold", "sponge", "prismarine", "tridents", "nautilus_shells"],
                "Ancient City": ["echo_shards", "disc_fragments", "enchanted_books", "suspicious_stew", "ward_armor"],
                "Nether Fortress": ["nether_wart", "blaze_rods", "wither_skulls", "gold", "netherite_scrap"],
                "Trial Chambers": ["diamonds", "enchanted_equipment", "trial_key", "experience_bottles"]
            }
        };

        const spacing = Object.fromEntries(
            Object.entries(Constants.STRUCTURES).map(([key, value]) => [key, value.spacing])
        );

        function MinecraftRandom(seed) {
            let instanceSeed = typeof seed === 'bigint' ? seed : BigInt(seed);
            instanceSeed = instanceSeed & ((BigInt(1) << BigInt(48)) - BigInt(1));
            
            return {
                nextInt: function(bound) {
                    if (bound <= 0) throw new Error("Bound must be positive");
                    instanceSeed = (instanceSeed * BigInt(0x5DEECE66D) + BigInt(0xB)) & ((BigInt(1) << BigInt(48)) - BigInt(1));
                    return Number(instanceSeed >> BigInt(16)) % bound;
                },
                nextFloat: function() {
                    instanceSeed = (instanceSeed * BigInt(0x5DEECE66D) + BigInt(0xB)) & ((BigInt(1) << BigInt(48)) - BigInt(1));
                    return Number(instanceSeed >> BigInt(24)) / (1 << 24);
                },
                nextLong: function() {
                    instanceSeed = (instanceSeed * BigInt(0x5DEECE66D) + BigInt(0xB)) & ((BigInt(1) << BigInt(48)) - BigInt(1));
                    return instanceSeed;
                }
            };
        }

        function perlinNoise(x, z, seed, scale = Constants.WORLD_SETTINGS.NOISE_SCALE, octaves = Constants.WORLD_SETTINGS.NOISE_OCTAVES) {
            let total = 0;
            for (let i = 0; i < octaves; i++) {
                const frequency = scale * Math.pow(2, i);
                const amplitude = Math.pow(Constants.WORLD_SETTINGS.NOISE_PERSISTENCE, i);
                const randSeed = seed + BigInt(i * 1000);
                const rand = MinecraftRandom(randSeed);
                const gridX = Math.floor(x * frequency);
                const gridZ = Math.floor(z * frequency);
                const n00 = rand.nextFloat() * 2 - 1;
                const n10 = rand.nextFloat() * 2 - 1;
                const n01 = rand.nextFloat() * 2 - 1;
                const n11 = rand.nextFloat() * 2 - 1;
                const fx = (x * frequency) - gridX;
                const fz = (z * frequency) - gridZ;
                const u = fx * fx * (3 - 2 * fx);
                const v = fz * fz * (3 - 2 * fz);
                const lerpX0 = n00 + u * (n10 - n00);
                const lerpX1 = n01 + u * (n11 - n01);
                total += (lerpX0 + v * (lerpX1 - lerpX0)) * amplitude;
            }
            return total;
        }

        function getBiomeAt(seed, x, z, version, dimension = "overworld") {
            try {
                seed = typeof seed === 'string' ? BigInt(seed) : seed;
                const biomeMap = Constants.BIOME_WEIGHTS[dimension.toUpperCase()] || Constants.BIOME_WEIGHTS.OVERWORLD;
                const noiseSeed = seed + BigInt(x) * BigInt(341873128712) + BigInt(z) * BigInt(132897987541);
                const noise = perlinNoise(x, z, noiseSeed);
                const biomeId = Math.floor((noise + 1) * 100);
                let cumWeight = 0;
                for (const biome in biomeMap) {
                    cumWeight += biomeMap[biome] * 100;
                    if (biomeId <= cumWeight) return [biome, 1];
                }
                return ["Plains", 1];
            } catch (error) {
                console.error("Error in getBiomeAt:", error);
                return ["Plains", 1];
            }
        }

        function getStructurePos(seed, structure, version, radius, filters = {}) {
            try {
                const versionNum = parseFloat(version);
                const biomeRequirements = {
                    Village: ["Plains", "Desert", "Savanna", "Taiga", "Meadow", "Snowy Plains"],
                    Temple: ["Desert", "Jungle", "Swamp", "Snowy Plains"],
                    Monument: ["Ocean", "Deep Ocean", "Warm Ocean"],
                    Mansion: ["Dark Forest", "Flower Forest"],
                    "Ancient City": ["Deep Dark"],
                    "Bastion Remnant": ["Nether Wastes", "Crimson Forest", "Warped Forest", "Soul Sand Valley", "Basalt Deltas"],
                    "Nether Fortress": ["Nether Wastes", "Crimson Forest", "Warped Forest", "Soul Sand Valley", "Basalt Deltas"],
                    "Trial Chambers": ["Deep Dark"],
                    "Stronghold": ["Plains", "Desert", "Forest", "Taiga", "Jungle", "Swamp", "Mesa"]
                };
                
                let structureSeed = seed;
                for (let i = 0; i < structure.length; i++) {
                    structureSeed = (structureSeed * 31 + BigInt(structure.charCodeAt(i))) & ((BigInt(1) << BigInt(48)) - BigInt(1));
                }
                
                const rand = MinecraftRandom(seed + structureSeed);
                const minDist = Constants.STRUCTURES[structure].minDist;
                let blockX, blockZ;
                
                if (structure === "Stronghold" && versionNum < 1.18) {
                    const ring = rand.nextInt(3);
                    const minRadius = [1408, 2720, 4032][ring];
                    const maxRadius = [2688, 4000, 5312][ring];
                    const angle = rand.nextFloat() * 2 * Math.PI;
                    const distance = minRadius + rand.nextFloat() * (maxRadius - minRadius);
                    blockX = Math.round(Math.cos(angle) * distance);
                    blockZ = Math.round(Math.sin(angle) * distance);
                } else {
                    const regionSize = spacing[structure] * Constants.WORLD_SETTINGS.CHUNK_SIZE;
                    const maxRegions = Math.floor(radius / regionSize);
                    const regionX = rand.nextInt(maxRegions * 2) - maxRegions;
                    const regionZ = rand.nextInt(maxRegions * 2) - maxRegions;
                    blockX = (regionX * regionSize) + rand.nextInt(regionSize);
                    blockZ = (regionZ * regionSize) + rand.nextInt(regionSize);
                }
                
                const distance = Math.sqrt(blockX * blockX + blockZ * blockZ);
                if (distance <= radius && distance >= minDist * Constants.WORLD_SETTINGS.CHUNK_SIZE) {
                    if (filters.stronghold_distance && structure === "Stronghold" && distance > filters.stronghold_distance) {
                        return null;
                    }
                    
                    const checkDimension = ["Bastion Remnant", "Nether Fortress"].includes(structure) ? "nether" : "overworld";
                    const checkOffsets = [[0, 0], [8, 8], [-8, -8], [8, -8], [-8, 8]];
                    for (const [dx, dz] of checkOffsets) {
                        const biomeResult = getBiomeAt(seed, blockX + dx, blockZ + dz, version, checkDimension);
                        if (biomeRequirements[structure] && !biomeRequirements[structure].includes(biomeResult[0])) {
                            return null;
                        }
                    }
                    
                    let desc = structure;
                    if (structure === "Temple") {
                        const templeTypes = ["Desert", "Jungle", "Swamp", "Igloo"];
                        const templeType = templeTypes[rand.nextInt(templeTypes.length)];
                        if (filters.temple_type && filters.temple_type !== "Any" && templeType !== filters.temple_type) return null;
                        desc = `Temple (${templeType})`;
                    } else if (structure === "Bastion Remnant") {
                        const bastionTypes = ["Hoglin Stable", "Housing Units", "Treasure", "Bridge"];
                        const bastionType = bastionTypes[rand.nextInt(bastionTypes.length)];
                        if (filters.bastion_type && filters.bastion_type !== "Any" && bastionType !== filters.bastion_type) return null;
                        desc = `Bastion Remnant (${bastionType})`;
                    } else if (structure === "Trial Chambers") {
                        const chamberTypes = ["Small", "Medium", "Large"];
                        desc = `Trial Chambers (${chamberTypes[rand.nextInt(chamberTypes.length)]})`;
                    }
                    
                    return [blockX, blockZ, desc, distance];
                }
                
                return null;
            } catch (error) {
                console.error("Error in getStructurePos:", error);
                return null;
            }
        }

        function analyzeBiomeDistribution(seed, version, radius = Constants.WORLD_SETTINGS.BIOME_ANALYSIS_RADIUS, dimension = "overworld") {
            try {
                const isMobile = window.innerWidth < 768;
                const step = isMobile ? Math.floor(radius / 50) : Math.floor(radius / 100);
                const points = Array.from({ length: isMobile ? 100 : 200 }, (_, i) => -radius + (i * 2 * radius) / (isMobile ? 99 : 199));
                const biomeCounts = {};
                
                for (const x of points) {
                    for (const z of points) {
                        const biomeResult = getBiomeAt(seed, Math.floor(x), Math.floor(z), version, dimension);
                        biomeCounts[biomeResult[0]] = (biomeCounts[biomeResult[0]] || 0) + 1;
                    }
                }
                
                const total = Object.values(biomeCounts).reduce((sum, count) => sum + count, 0);
                return Object.fromEntries(
                    Object.entries(biomeCounts).map(([biome, count]) => [biome, (count / total * 100)])
                );
            } catch (error) {
                console.error("Error in analyzeBiomeDistribution:", error);
                return {};
            }
        }

        function App() {
            const [version, setVersion] = React.useState("1.21");
            const [biomes, setBiomes] = React.useState(["Plains"]);
            const [structures, setStructures] = React.useState([]);
            const [radius, setRadius] = React.useState(500);
            const [priority, setPriority] = React.useState("none");
            const [filters, setFilters] = React.useState({ temple_type: "Any", bastion_type: "Any", stronghold_distance: 0 });
            const [currentSeed, setCurrentSeed] = React.useState(null);
            const [positions, setPositions] = React.useState({});
            const [biomeDist, setBiomeDist] = React.useState({});
            const [biomeDistNether, setBiomeDistNether] = React.useState({});
            const [isRunning, setIsRunning] = React.useState(false);
            const [progress, setProgress] = React.useState(0);
            const [attempts, setAttempts] = React.useState(0);
            const [startTime, setStartTime] = React.useState(0);
            const [result, setResult] = React.useState("");
            const [dimension, setDimension] = React.useState("overworld");
            const [zoom, setZoom] = React.useState(1.0);
            const [panOffset, setPanOffset] = React.useState({ x: 0, y: 0 });
            const [isPanning, setIsPanning] = React.useState(false);
            const [panStart, setPanStart] = React.useState({ x: 0, y: 0 });
            const [profiles, setProfiles] = React.useState({});
            const [selectedProfile, setSelectedProfile] = React.useState("");
            const [error, setError] = React.useState("");
            const [showMobileWarning, setShowMobileWarning] = React.useState(false);
            
            const canvasRef = React.useRef(null);
            const workerRef = React.useRef(null);
            const containerRef = React.useRef(null);

            // Load profiles
            React.useEffect(() => {
                try {
                    const savedProfiles = localStorage.getItem("profiles");
                    if (savedProfiles) setProfiles(JSON.parse(savedProfiles));
                } catch (e) {
                    setError("Failed to load profiles. Using defaults.");
                    setTimeout(() => setError(""), 5000);
                }
            }, []);

            // Initialize Web Worker
            React.useEffect(() => {
                const workerCode = `
                    ${MinecraftRandom.toString()}
                    ${perlinNoise.toString()}
                    ${getBiomeAt.toString()}
                    ${getStructurePos.toString()}
                    ${analyzeBiomeDistribution.toString()}
                    self.Constants = ${JSON.stringify(Constants)};
                    self.spacing = ${JSON.stringify(spacing)};
                    
                    self.onmessage = function(e) {
                        const { version, biomes, structures, radius, filters, maxAttempts, priority } = e.data;
                        let attempts = 0;
                        
                        while (attempts < maxAttempts) {
                            let seed;
                            try {
                                if (self.crypto?.getRandomValues) {
                                    const array = new BigUint64Array(1);
                                    self.crypto.getRandomValues(array);
                                    seed = array[0];
                                } else {
                                    seed = BigInt(Math.floor(Math.random() * 9007199254740991));
                                }
                            } catch (e) {
                                seed = BigInt(Math.floor(Math.random() * 9007199254740991));
                            }
                            
                            let biomeValid = true;
                            const spawnRadius = ${Constants.WORLD_SETTINGS.SPAWN_CHECK_RADIUS};
                            const spawnPoints = [];
                            for (let x = -spawnRadius; x <= spawnRadius; x += 16) {
                                for (let z = -spawnRadius; z <= spawnRadius; z += 16) {
                                    spawnPoints.push([x, z]);
                                }
                            }
                            
                            for (const biome of biomes) {
                                let found = false;
                                for (const [x, z] of spawnPoints) {
                                    try {
                                        if (getBiomeAt(seed, x, z, version, 'overworld')[0] === biome) {
                                            found = true;
                                            break;
                                        }
                                    } catch (e) {}
                                }
                                if (!found) {
                                    biomeValid = false;
                                    break;
                                }
                            }
                            
                            if (!biomeValid) {
                                attempts++;
                                continue;
                            }
                            
                            let structurePositions = {};
                            let valid = true;
                            let totalDistance = 0;
                            
                            for (const struct of structures) {
                                try {
                                    const pos = getStructurePos(seed, struct, version, radius, filters);
                                    if (pos) {
                                        structurePositions[struct] = pos;
                                        totalDistance += pos[3];
                                    } else {
                                        valid = false;
                                        break;
                                    }
                                } catch (e) {
                                    valid = false;
                                    break;
                                }
                            }
                            
                            if (valid && priority === 'distance' && structures.length > 0) {
                                if (totalDistance / structures.length > radius * 0.3) {
                                    valid = false;
                                }
                            }
                            
                            if (valid) {
                                try {
                                    const biomeDist = analyzeBiomeDistribution(seed, version, ${Constants.WORLD_SETTINGS.BIOME_ANALYSIS_RADIUS}, 'overworld');
                                    const biomeDistNether = analyzeBiomeDistribution(seed, version, ${Constants.WORLD_SETTINGS.BIOME_ANALYSIS_RADIUS}, 'nether');
                                    self.postMessage({
                                        seed: seed.toString(),
                                        status: 'Accepted',
                                        structurePositions,
                                        biomeDist,
                                        biomeDistNether,
                                        attempts
                                    });
                                    return;
                                } catch (e) {}
                            }
                            
                            attempts++;
                            if (attempts % 25 === 0) {
                                self.postMessage({ progress: Math.min((attempts / maxAttempts) * 100, 99.9), attempts });
                            }
                            if (attempts % 1000 === 0) setTimeout(() => {}, 0);
                        }
                        
                        self.postMessage({ status: 'No valid seed found', attempts });
                    };
                `;
                
                try {
                    const blob = new Blob([workerCode], { type: 'application/javascript' });
                    workerRef.current = new Worker(URL.createObjectURL(blob));
                    workerRef.current.onmessage = (e) => {
                        const { progress, attempts, status, seed, structurePositions, biomeDist, biomeDistNether } = e.data;
                        if (progress !== undefined) {
                            setProgress(progress);
                            setAttempts(attempts || 0);
                            return;
                        }
                        if (status === "Accepted") {
                            setCurrentSeed(seed);
                            setPositions(structurePositions);
                            setBiomeDist(biomeDist || {});
                            setBiomeDistNether(biomeDistNether || {});
                            const seedNum = Number(seed.substring(0, 15));
                            const structureLines = Object.entries(structurePositions)
                                .map(([key, pos]) => `  ${pos[2]} at (${pos[0]}, ${pos[1]}) (Distance: ${pos[3].toFixed(1)})`)
                                .sort((a, b) => parseFloat(a.match(/Distance: ([\d.]+)/)[1]) - parseFloat(b.match(/Distance: ([\d.]+)/)[1]));
                            const biomeDistLines = Object.entries(biomeDist)
                                .sort(([,a], [,b]) => b - a)
                                .map(([biome, percent]) => `  ${biome}: ${percent.toFixed(2)}%`);
                            const biomeDistNetherLines = Object.entries(biomeDistNether)
                                .sort(([,a], [,b]) => b - a)
                                .map(([biome, percent]) => `  ${biome}: ${percent.toFixed(2)}%`);
                            setResult(`Seed: ${seedNum}
Biomes: ${biomes.join(", ")}
Version: ${version}
Structures:
${structureLines.join("\n")}
Biome Distribution (Overworld, ${Constants.WORLD_SETTINGS.BIOME_ANALYSIS_RADIUS}x${Constants.WORLD_SETTINGS.BIOME_ANALYSIS_RADIUS} blocks):
${biomeDistLines.join("\n")}
Biome Distribution (Nether, ${Constants.WORLD_SETTINGS.BIOME_ANALYSIS_RADIUS}x${Constants.WORLD_SETTINGS.BIOME_ANALYSIS_RADIUS} blocks):
${biomeDistNetherLines.join("\n")}`);
                            setIsRunning(false);
                        } else {
                            setResult("No valid seed found. Try adjusting criteria.");
                            setIsRunning(false);
                        }
                    };
                    workerRef.current.onerror = (error) => {
                        setError(`Worker error: ${error.message || "Unknown error"}`);
                        setIsRunning(false);
                        setTimeout(() => setError(""), 5000);
                    };
                } catch (e) {
                    setError("Failed to initialize Web Worker. Using fallback mode.");
                    workerRef.current = null;
                }
                
                return () => workerRef.current?.terminate();
            }, []);

            // Canvas rendering
            React.useEffect(() => {
                if (!canvasRef.current || !currentSeed || !Object.keys(positions).length) return;
                
                const canvas = canvasRef.current;
                const ctx = canvas.getContext("2d");
                const container = containerRef.current;
                const dpr = window.devicePixelRatio || 1;
                const rect = container.getBoundingClientRect();
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                ctx.scale(dpr, dpr);
                
                const width = rect.width;
                const height = rect.height;
                ctx.clearRect(0, 0, width, height);
                
                const scale = Math.min(width, height) / (2 * radius) * zoom;
                const centerX = width / 2;
                const centerY = height / 2;
                
                const biomeColors = {
                    "Plains": "#90EE90", "Forest": "#228B22", "Desert": "#EDC9AF", "Taiga": "#2F4F4F",
                    "Swamp": "#6B8E23", "Jungle": "#006400", "Savanna": "#DAA520", "Badlands": "#8B0000",
                    "Mushroom Fields": "#FFE4E1", "Deep Dark": "#1C2526", "Mangrove Swamp": "#3CB371",
                    "Cherry Grove": "#FF69B4", "Lush Caves": "#00CED1", "Snowy Plains": "#F0F8FF",
                    "Ocean": "#1E90FF", "Meadow": "#98FB98", "Bamboo Jungle": "#9ACD32",
                    "Nether Wastes": "#8B0000", "Crimson Forest": "#DC143C", "Warped Forest": "#20B2AA",
                    "Soul Sand Valley": "#B0C4DE", "Basalt Deltas": "#696969", "Giant Tree Taiga": "#3A5F0B",
                    "Stone Shore": "#808080", "River": "#4682B4", "Beach": "#F5DEB3", "Dark Forest": "#191970"
                };
                
                const structureColors = {
                    "Village": "#FFD700", "Mineshaft": "#808080", "Stronghold": "#800080", "Temple": "#FFA500",
                    "Monument": "#0000FF", "Mansion": "#8B4513", "Bastion Remnant": "#000000", "Ancient City": "#00FFFF",
                    "Nether Fortress": "#FF0000", "Trial Chambers": "#FF00FF", "Ruined Portal": "#A52A2A"
                };
                
                const isMobile = window.innerWidth < 768;
                const analysisRadius = Constants.WORLD_SETTINGS.BIOME_ANALYSIS_RADIUS;
                const step = isMobile ? Math.floor(analysisRadius / 40) : Math.floor(analysisRadius / 80);
                const visibleMinX = -width/(2*scale) - panOffset.x/scale;
                const visibleMaxX = width/(2*scale) - panOffset.x/scale;
                const visibleMinZ = -height/(2*scale) - panOffset.y/scale;
                const visibleMaxZ = height/(2*scale) - panOffset.y/scale;
                
                for (let x = Math.max(-analysisRadius, visibleMinX - step); x <= Math.min(analysisRadius, visibleMaxX + step); x += step) {
                    for (let z = Math.max(-analysisRadius, visibleMinZ - step); z <= Math.min(analysisRadius, visibleMaxZ + step); z += step) {
                        try {
                            const biome = getBiomeAt(BigInt(currentSeed), x, z, version, dimension)[0];
                            const color = biomeColors[biome] || "#2b2b2b";
                            const screenX = centerX + (x * scale) + panOffset.x;
                            const screenY = centerY + (z * scale) + panOffset.y;
                            if (screenX > -step * scale && screenX < width + step * scale &&
                                screenY > -step * scale && screenY < height + step * scale) {
                                ctx.fillStyle = color;
                                ctx.globalAlpha = 0.5;
                                ctx.fillRect(screenX - step * scale / 2, screenY - step * scale / 2, step * scale, step * scale);
                                ctx.globalAlpha = 1.0;
                            }
                        } catch (e) {}
                    }
                }
                
                if (dimension === "overworld") {
                    ctx.fillStyle = "red";
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 6, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.strokeStyle = "black";
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.lineWidth = 1;
                }
                
                for (const struct in positions) {
                    const pos = positions[struct];
                    if (!pos || (dimension === "nether" && !["Bastion Remnant", "Nether Fortress"].includes(struct)) ||
                        (dimension === "overworld" && ["Bastion Remnant", "Nether Fortress"].includes(struct))) continue;
                    
                    const [x, z, desc] = pos;
                    const screenX = centerX + (x * scale) + panOffset.x;
                    const screenY = centerY + (z * scale) + panOffset.y;
                    if (screenX > -20 && screenX < width + 20 && screenY > -20 && screenY < height + 20) {
                        ctx.fillStyle = structureColors[struct] || "white";
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, 6, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.strokeStyle = "black";
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        ctx.lineWidth = 1;
                        ctx.fillStyle = "#e0e0e0";
                        ctx.font = "12px Arial";
                        ctx.textAlign = "left";
                        ctx.fillText(desc, screenX + 10, screenY + 4);
                        ctx.textAlign = "start";
                    }
                }
            }, [currentSeed, positions, version, dimension, zoom, panOffset, radius]);

            // Fallback seed generation for non-Web Worker environments
            const generateSeedFallback = (version, biomes, structures, radius, filters, priority, maxAttempts) => {
                let attempts = 0;
                while (attempts < Math.min(maxAttempts, 10000)) { // Reduced for performance
                    const seed = BigInt(Math.floor(Math.random() * 9007199254740991));
                    let biomeValid = true;
                    const spawnRadius = Constants.WORLD_SETTINGS.SPAWN_CHECK_RADIUS;
                    const spawnPoints = [];
                    for (let x = -spawnRadius; x <= spawnRadius; x += 16) {
                        for (let z = -spawnRadius; z <= spawnRadius; z += 16) {
                            spawnPoints.push([x, z]);
                        }
                    }
                    
                    for (const biome of biomes) {
                        let found = false;
                        for (const [x, z] of spawnPoints) {
                            if (getBiomeAt(seed, x, z, version, 'overworld')[0] === biome) {
                                found = true;
                                break;
                            }
                        }
                        if (!found) {
                            biomeValid = false;
                            break;
                        }
                    }
                    
                    if (!biomeValid) {
                        attempts++;
                        setProgress(Math.min((attempts / maxAttempts) * 100, 99.9));
                        setAttempts(attempts);
                        continue;
                    }
                    
                    let structurePositions = {};
                    let valid = true;
                    let totalDistance = 0;
                    for (const struct of structures) {
                        const pos = getStructurePos(seed, struct, version, radius, filters);
                        if (pos) {
                            structurePositions[struct] = pos;
                            totalDistance += pos[3];
                        } else {
                            valid = false;
                            break;
                        }
                    }
                    
                    if (valid && priority === 'distance' && structures.length > 0) {
                        if (totalDistance / structures.length > radius * 0.3) {
                            valid = false;
                        }
                    }
                    
                    if (valid) {
                        const biomeDist = analyzeBiomeDistribution(seed, version, Constants.WORLD_SETTINGS.BIOME_ANALYSIS_RADIUS, 'overworld');
                        const biomeDistNether = analyzeBiomeDistribution(seed, version, Constants.WORLD_SETTINGS.BIOME_ANALYSIS_RADIUS, 'nether');
                        return { seed: seed.toString(), structurePositions, biomeDist, biomeDistNether, attempts };
                    }
                    
                    attempts++;
                    setProgress(Math.min((attempts / maxAttempts) * 100, 99.9));
                    setAttempts(attempts);
                }
                return { status: 'No valid seed found', attempts };
            };

            // Find valid seed
            const findValidSeed = React.useCallback(() => {
                if (isRunning) return;
                if (!biomes.length) {
                    setError("Select at least one biome.");
                    setTimeout(() => setError(""), 5000);
                    return;
                }
                if (!structures.length) {
                    setError("Select at least one structure.");
                    setTimeout(() => setError(""), 5000);
                    return;
                }
                if (radius < 100 || radius > 4000) {
                    setError("Radius must be between 100 and 4000.");
                    setTimeout(() => setError(""), 5000);
                    return;
                }
                
                setShowMobileWarning(window.innerWidth < 768);
                setTimeout(() => setShowMobileWarning(false), 3000);
                setIsRunning(true);
                setProgress(0);
                setAttempts(0);
                setStartTime(Date.now());
                setResult("Generating seed...");
                setError("");
                
                if (workerRef.current) {
                    workerRef.current.postMessage({
                        version,
                        biomes,
                        structures,
                        radius,
                        filters,
                        priority,
                        maxAttempts: window.innerWidth < 768 ? 25000 : Constants.WORLD_SETTINGS.SEARCH_ITERATIONS
                    });
                } else {
                    setTimeout(() => {
                        const result = generateSeedFallback(version, biomes, structures, radius, filters, priority, 10000);
                        if (result.status === 'No valid seed found') {
                            setResult("No valid seed found. Try adjusting criteria.");
                            setIsRunning(false);
                            return;
                        }
                        setCurrentSeed(result.seed);
                        setPositions(result.structurePositions);
                        setBiomeDist(result.biomeDist);
                        setBiomeDistNether(result.biomeDistNether);
                        const seedNum = Number(result.seed.substring(0, 15));
                        const structureLines = Object.entries(result.structurePositions)
                            .map(([key, pos]) => `  ${pos[2]} at (${pos[0]}, ${pos[1]}) (Distance: ${pos[3].toFixed(1)})`)
                            .sort((a, b) => parseFloat(a.match(/Distance: ([\d.]+)/)[1]) - parseFloat(b.match(/Distance: ([\d.]+)/)[1]));
                        const biomeDistLines = Object.entries(result.biomeDist)
                            .sort(([,a], [,b]) => b - a)
                            .map(([biome, percent]) => `  ${biome}: ${percent.toFixed(2)}%`);
                        const biomeDistNetherLines = Object.entries(result.biomeDistNether)
                            .sort(([,a], [,b]) => b - a)
                            .map(([biome, percent]) => `  ${biome}: ${percent.toFixed(2)}%`);
                        setResult(`Seed: ${seedNum}
Biomes: ${biomes.join(", ")}
Version: ${version}
Structures:
${structureLines.join("\n")}
Biome Distribution (Overworld, ${Constants.WORLD_SETTINGS.BIOME_ANALYSIS_RADIUS}x${Constants.WORLD_SETTINGS.BIOME_ANALYSIS_RADIUS} blocks):
${biomeDistLines.join("\n")}
Biome Distribution (Nether, ${Constants.WORLD_SETTINGS.BIOME_ANALYSIS_RADIUS}x${Constants.WORLD_SETTINGS.BIOME_ANALYSIS_RADIUS} blocks):
${biomeDistNetherLines.join("\n")}`);
                        setIsRunning(false);
                    }, 0);
                }
            }, [isRunning, biomes, structures, version, radius, filters, priority]);

            // Stop search
            const stopSearch = React.useCallback(() => {
                if (workerRef.current) {
                    workerRef.current.terminate();
                    workerRef.current = null;
                }
                setIsRunning(false);
                setResult("Search stopped.");
            }, []);

            // Handle biome addition
            const addBiome = (biome) => {
                if (biomes.length >= 3) {
                    setError("Maximum 3 biomes allowed!");
                    setTimeout(() => setError(""), 5000);
                    return;
                }
                if (!biomes.includes(biome)) setBiomes([...biomes, biome]);
            };

            // Handle structure toggle
            const toggleStructure = (struct) => {
                if (structures.includes(struct)) {
                    setStructures(structures.filter(s => s !== struct));
                } else if (structures.length < 3) {
                    setStructures([...structures, struct]);
                } else {
                    setError("Maximum 3 structures allowed!");
                    setTimeout(() => setError(""), 5000);
                }
            };

            // Save profile
            const saveProfile = () => {
                const name = prompt("Enter profile name:");
                if (!name?.trim()) {
                    setError("Profile name cannot be empty!");
                    setTimeout(() => setError(""), 5000);
                    return;
                }
                try {
                    const profile = { version, biomes, structures, radius, priority, filters };
                    const newProfiles = { ...profiles, [name.trim()]: profile };
                    setProfiles(newProfiles);
                    localStorage.setItem("profiles", JSON.stringify(newProfiles));
                    setSelectedProfile(name.trim());
                } catch (e) {
                    setError("Failed to save profile!");
                    setTimeout(() => setError(""), 5000);
                }
            };

            // Load profile
            const loadProfile = (name) => {
                if (name && profiles[name]) {
                    const profile = profiles[name];
                    if (Array.isArray(profile.biomes) && Array.isArray(profile.structures)) {
                        setVersion(profile.version || "1.21");
                        setBiomes(profile.biomes);
                        setStructures(profile.structures);
                        setRadius(profile.radius || 500);
                        setPriority(profile.priority || "none");
                        setFilters(profile.filters || { temple_type: "Any", bastion_type: "Any", stronghold_distance: 0 });
                        setSelectedProfile(name);
                    } else {
                        setError("Invalid profile data!");
                        setTimeout(() => setError(""), 5000);
                    }
                }
            };

            // Delete profile
            const deleteProfile = () => {
                if (selectedProfile && window.confirm(`Delete profile "${selectedProfile}"?`)) {
                    try {
                        const newProfiles = { ...profiles };
                        delete newProfiles[selectedProfile];
                        setProfiles(newProfiles);
                        localStorage.setItem("profiles", JSON.stringify(newProfiles));
                        setSelectedProfile("");
                    } catch (e) {
                        setError("Failed to delete profile!");
                        setTimeout(() => setError(""), 5000);
                    }
                }
            };

            // Export results
            const exportResults = () => {
                if (!currentSeed) {
                    setError("No seed to export!");
                    setTimeout(() => setError(""), 5000);
                    return;
                }
                try {
                    const resultData = {
                        seed: currentSeed,
                        biomes,
                        structures: positions,
                        radius,
                        version,
                        biome_distribution_overworld: biomeDist,
                        biome_distribution_nether: biomeDistNether,
                        timestamp: new Date().toISOString(),
                        criteria: { priority, ...filters },
                        application: "Minecraft Seed Generator Ultimate",
                        version: "2.0"
                    };
                    const blob = new Blob([JSON.stringify(resultData, null, 2)], { type: "application/json" });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement("a");
                    a.href = url;
                    a.download = `minecraft_seed_${Date.now()}.json`;
                    a.click();
                    URL.revokeObjectURL(url);
                } catch (e) {
                    setError("Failed to export results!");
                    setTimeout(() => setError(""), 5000);
                }
            };

            // Copy seed
            const copySeed = () => {
                if (currentSeed) {
                    try {
                        navigator.clipboard.writeText(currentSeed).then(() => {
                            alert("Seed copied!");
                        }).catch(() => {
                            setError("Failed to copy seed!");
                            setTimeout(() => setError(""), 5000);
                        });
                    } catch (e) {
                        setError("Failed to copy seed!");
                        setTimeout(() => setError(""), 5000);
                    }
                } else {
                    setError("No seed to copy!");
                    setTimeout(() => setError(""), 5000);
                }
            };

            // Handle canvas interactions
            const handlePanStart = (e) => {
                e.preventDefault();
                setIsPanning(true);
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                setPanStart({ x: clientX, y: clientY });
            };

            const handlePanMove = React.useCallback((e) => {
                if (!isPanning) return;
                e.preventDefault();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                setPanOffset(prev => ({
                    x: prev.x + (clientX - panStart.x),
                    y: prev.y + (clientY - panStart.y)
                }));
                setPanStart({ x: clientX, y: clientY });
            }, [isPanning, panStart]);

            const handlePanEnd = () => setIsPanning(false);

            // Reset settings
            const resetSettings = () => {
                if (window.confirm("Reset all settings?")) {
                    setVersion("1.21");
                    setBiomes(["Plains"]);
                    setStructures([]);
                    setRadius(500);
                    setPriority("none");
                    setFilters({ temple_type: "Any", bastion_type: "Any", stronghold_distance: 0 });
                    setSelectedProfile("");
                    setCurrentSeed(null);
                    setPositions({});
                    setBiomeDist({});
                    setBiomeDistNether({});
                    setResult("");
                    setZoom(1.0);
                    setPanOffset({ x: 0, y: 0 });
                }
            };

            // Format time
            const formatTime = () => startTime ? ((Date.now() - startTime) / 1000).toFixed(1) : "0.0";

            const biomeOptions = Object.keys(Constants.BIOME_WEIGHTS.OVERWORLD).sort();
            const structureOptions = Object.keys(Constants.STRUCTURES)
                .filter(s => !["End City", "Ruined Portal"].includes(s))
                .sort();

            return (
                <div className="container">
                    <div className="control-panel scrollbar-custom">
                        <div className="panel">
                            <div className="mobile-header">
                                <h1 className="text-lg font-bold text-green-400 mb-4">Minecraft Seed Generator</h1>
                            </div>
                            {error && <div className="error-message">{error}</div>}
                            {showMobileWarning && (
                                <div className="mobile-warning">Seed generation may be slower on mobile.</div>
                            )}
                            <div className="mb-4">
                                <label className="block text-sm mb-2">Minecraft Version:</label>
                                <select value={version} onChange={(e) => setVersion(e.target.value)} className="input" aria-label="Minecraft Version">
                                    {["1.14", "1.15", "1.16", "1.17", "1.18", "1.19", "1.20", "1.21"].map(v => (
                                        <option key={v} value={v}>{v}</option>
                                    ))}
                                </select>
                            </div>
                            <div className="mb-4">
                                <label className="block text-sm mb-2">Spawn Biomes (up to 3):</label>
                                {biomes.map((b, i) => (
                                    <select key={i} value={b} onChange={(e) => {
                                        const newBiomes = [...biomes];
                                        newBiomes[i] = e.target.value;
                                        setBiomes(newBiomes);
                                    }} className="input mb-2" aria-label={`Biome ${i + 1}`}>
                                        {biomeOptions.map(o => (
                                            <option key={o} value={o}>{o}</option>
                                        ))}
                                    </select>
                                ))}
                                <button onClick={() => addBiome(biomeOptions[0])} className="btn btn-success mt-2" aria-label="Add Biome">Add Biome</button>
                            </div>
                            <div className="mb-4">
                                <label className="block text-sm mb-2">Structures (up to 3):</label>
                                <div className="grid grid-cols-2 gap-2">
                                    {structureOptions.map(s => (
                                        <label key={s} className="flex items-center">
                                            <input type="checkbox" checked={structures.includes(s)} onChange={() => toggleStructure(s)} className="mr-2" aria-label={s} />
                                            {s}
                                        </label>
                                    ))}
                                </div>
                            </div>
                            <div className="mb-4">
                                <label className="block text-sm mb-2">Structure Filters:</label>
                                <div className="space-y-2">
                                    <div>
                                        <label className="block text-xs mb-1">Temple Type:</label>
                                        <select value={filters.temple_type} onChange={(e) => setFilters({...filters, temple_type: e.target.value})} className="input" aria-label="Temple Type">
                                            {["Any", "Desert", "Jungle", "Swamp", "Igloo"].map(t => (
                                                <option key={t} value={t}>{t}</option>
                                            ))}
                                        </select>
                                    </div>
                                    <div>
                                        <label className="block text-xs mb-1">Bastion Type:</label>
                                        <select value={filters.bastion_type} onChange={(e) => setFilters({...filters, bastion_type: e.target.value})} className="input" aria-label="Bastion Type">
                                            {["Any", "Hoglin Stable", "Housing Units", "Treasure", "Bridge"].map(t => (
                                                <option key={t} value={t}>{t}</option>
                                            ))}
                                        </select>
                                    </div>
                                    <div>
                                        <label className="block text-xs mb-1">Max Stronghold Distance:</label>
                                        <input type="number" value={filters.stronghold_distance} onChange={(e) => setFilters({...filters, stronghold_distance: parseFloat(e.target.value) || 0})} className="input" min="0" max="4000" aria-label="Max Stronghold Distance" />
                                    </div>
                                </div>
                            </div>
                            <div className="mb-4">
                                <label className="block text-sm mb-2">Priority:</label>
                                <div className="space-y-2">
                                    <label className="flex items-center">
                                        <input type="radio" name="priority" value="none" checked={priority === "none"} onChange={(e) => setPriority(e.target.value)} className="mr-2" aria-label="No Priority" />
                                        None
                                    </label>
                                    <label className="flex items-center">
                                        <input type="radio" name="priority" value="distance" checked={priority === "distance"} onChange={(e) => setPriority(e.target.value)} className="mr-2" aria-label="Closer Structures" />
                                        Closer Structures
                                    </label>
                                </div>
                            </div>
                            <div className="mb-4">
                                <label className="block text-sm mb-2">Search Radius (blocks): {radius}</label>
                                <input type="range" min="100" max="4000" value={radius} onChange={(e) => setRadius(parseInt(e.target.value))} className="input-range" aria-label="Search Radius" />
                                <div className="flex justify-between text-xs text-gray-400">
                                    <span>100</span>
                                    <span>4000</span>
                                </div>
                            </div>
                            <div className="mb-4">
                                <label className="block text-sm mb-2">Saved Profiles:</label>
                                <select value={selectedProfile} onChange={(e) => loadProfile(e.target.value)} className="input mb-2" aria-label="Saved Profiles">
                                    <option value="">Select Profile</option>
                                    {Object.keys(profiles).map(p => (
                                        <option key={p} value={p}>{p}</option>
                                    ))}
                                </select>
                                <div className="flex gap-2 mobile-controls">
                                    <button onClick={saveProfile} className="btn btn-secondary" aria-label="Save Profile">Save Profile</button>
                                    <button onClick={deleteProfile} className="btn btn-danger" aria-label="Delete Profile">Delete</button>
                                </div>
                            </div>
                            <div className="mb-4 space-y-2">
                                <button onClick={findValidSeed} disabled={isRunning} className={`btn btn-primary ${isRunning ? 'opacity-75' : ''}`} aria-label="Generate Seed">{isRunning ? 'Generating...' : 'Generate Seed'}</button>
                                <button onClick={stopSearch} disabled={!isRunning} className={`btn btn-danger ${!isRunning ? 'opacity-75' : ''}`} aria-label="Stop Search">Stop Search</button>
                                <button onClick={exportResults} disabled={!currentSeed} className={`btn btn-secondary ${!currentSeed ? 'opacity-75' : ''}`} aria-label="Export Results">Export Results</button>
                                <button onClick={copySeed} disabled={!currentSeed} className={`btn btn-warning ${!currentSeed ? 'opacity-75' : ''}`} aria-label="Copy Seed">Copy Seed</button>
                                <button onClick={resetSettings} className="btn btn-success" aria-label="Reset Settings">Reset Settings</button>
                            </div>
                            <div className="mb-4">
                                <div className="progress-container">
                                    <div className="progress-bar" style={{width: `${progress}%`}}></div>
                                </div>
                                <div className="flex justify-between text-sm">
                                    <span>Attempts: {attempts}</span>
                                    <span>Time: {formatTime()}s</span>
                                </div>
                            </div>
                            <textarea value={result} readOnly className="result-textarea" placeholder="Generated seed results will appear here..." aria-label="Seed Results"></textarea>
                        </div>
                    </div>
                    <div className="map-panel">
                        <h2 className="text-lg font-bold text-green-400 mb-4">Map Preview</h2>
                        <div className="flex gap-4 mb-4">
                            <label className="flex items-center">
                                <input type="radio" name="dimension" value="overworld" checked={dimension === "overworld"} onChange={(e) => setDimension(e.target.value)} className="mr-2" aria-label="Overworld" />
                                Overworld
                            </label>
                            <label className="flex items-center">
                                <input type="radio" name="dimension" value="nether" checked={dimension === "nether"} onChange={(e) => setDimension(e.target.value)} className="mr-2" aria-label="Nether" />
                                Nether
                            </label>
                        </div>
                        <div className="canvas-container" ref={containerRef}>
                            <canvas
                                ref={canvasRef}
                                onMouseDown={handlePanStart}
                                onMouseMove={handlePanMove}
                                onMouseUp={handlePanEnd}
                                onMouseLeave={handlePanEnd}
                                onTouchStart={handlePanStart}
                                onTouchMove={handlePanMove}
                                onTouchEnd={handlePanEnd}
                            ></canvas>
                        </div>
                        <div className="mt-4 w-full">
                            <label className="block text-sm mb-2">Zoom: {zoom.toFixed(1)}x</label>
                            <input type="range" min="0.5" max="4.0" step="0.1" value={zoom} onChange={(e) => setZoom(parseFloat(e.target.value))} className="input-range" aria-label="Zoom" />
                        </div>
                    </div>
                </div>
            );
        }

        try {
            const root = ReactDOM.createRoot(document.getElementById("root"));
            root.render(React.createElement(App));
        } catch (error) {
            document.getElementById("root").innerHTML = `
                <div class="container">
                    <div class="panel">
                        <div class="error-message">
                            <h2>Application Error</h2>
                            <p>Failed to load the Minecraft Seed Generator.</p>
                            <p>Error: ${error.message}</p>
                            <button onclick="location.reload()" class="btn btn-primary mt-4">Reload Page</button>
                        </div>
                    </div>
                </div>
            `;
        }
    </script>
</body>
</html>
