<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Seed Generator Ultimate</title>
    <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <style>
        body { background-color: #1a1a1a; color: #e0e0e0; font-family: 'Arial', sans-serif; }
        .scrollbar-custom::-webkit-scrollbar { width: 8px; }
        .scrollbar-custom::-webkit-scrollbar-track { background: #2b2b2b; }
        .scrollbar-custom::-webkit-scrollbar-thumb { background: #4caf50; border-radius: 4px; }
        .scrollbar-custom::-webkit-scrollbar-thumb:hover { background: #66bb6a; }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        // Constants for structure generation and biome analysis
        const Constants = {
            STRUCTURES: {
                Village: { spacing: 32, minDist: 8, weight: 1.0, yRange: [-64, 319], types: ["Plains", "Desert", "Savanna", "Snowy", "Taiga"] },
                Mineshaft: { spacing: 1, minDist: 1, weight: 0.8, yRange: [-64, 30], types: ["Normal", "Mesa"] },
                Stronghold: { spacing: 16, minDist: 1, weight: 1.0, yRange: [-64, 30], special: true },
                Temple: { spacing: 32, minDist: 8, weight: 0.9, yRange: [-64, 319], types: ["Desert", "Jungle", "Swamp", "Igloo"] },
                Monument: { spacing: 32, minDist: 5, weight: 0.7, yRange: [0, 63], underwater: true },
                Mansion: { spacing: 80, minDist: 20, weight: 0.5, yRange: [60, 319], exclusive: true },
                "Bastion Remnant": { spacing: 27, minDist: 10, weight: 0.8, yRange: [0, 128], types: ["Bridge", "Hoglin Stable", "Housing", "Treasure"] },
                "Ancient City": { spacing: 24, minDist: 8, weight: 0.7, yRange: [-64, 0], deepslate: true },
                "Nether Fortress": { spacing: 16, minDist: 5, weight: 0.9, yRange: [0, 128], nether: true },
                "Trial Chambers": { spacing: 32, minDist: 8, weight: 0.6, yRange: [-64, 30], types: ["Small", "Medium", "Large"] },
                "End City": { spacing: 20, minDist: 11, weight: 0.8, yRange: [0, 256], end: true },
                "Ruined Portal": { spacing: 25, minDist: 8, weight: 0.9, yRange: [-64, 319], types: ["Standard", "Giant"] }
            },
            BIOME_WEIGHTS: {
                OVERWORLD: {
                    Plains: 0.35, Forest: 0.25, Desert: 0.15, Taiga: 0.15, Swamp: 0.10,
                    Jungle: 0.05, Savanna: 0.12, Badlands: 0.05, "Mushroom Fields": 0.005,
                    "Deep Dark": 0.04, "Mangrove Swamp": 0.05, "Cherry Grove": 0.03,
                    "Lush Caves": 0.04, "Snowy Plains": 0.08, Ocean: 0.25,
                    Meadow: 0.05, "Bamboo Jungle": 0.02, "Frozen Ocean": 0.08,
                    "Birch Forest": 0.12, "Dark Forest": 0.08
                },
                NETHER: {
                    "Nether Wastes": 0.30, "Crimson Forest": 0.25, "Warped Forest": 0.25,
                    "Soul Sand Valley": 0.15, "Basalt Deltas": 0.05
                },
                END: {
                    "End Highlands": 0.40, "End Midlands": 0.30, "End Barrens": 0.20,
                    "Small End Islands": 0.10
                }
            },
            WORLD_SETTINGS: {
                CHUNK_SIZE: 16,
                MAX_HEIGHT: 319,
                MIN_HEIGHT: -64,
                SEARCH_ITERATIONS: 20000,
                STRUCTURE_REGION_BITS: 12,
                MAX_CACHED_RESULTS: 1000,
                NOISE_OCTAVES: 8,
                NOISE_PERSISTENCE: 0.5,
                NOISE_SCALE: 0.007
            },
            LOOT_TABLES: {
                Village: ["iron", "food", "emeralds"],
                Temple: ["gold", "diamonds", "emeralds"],
                Monument: ["gold", "sponge", "prismarine"],
                "Ancient City": ["echo_shards", "disc_fragments", "enchanted_books"],
                "Nether Fortress": ["nether_wart", "blaze_rods", "wither_skulls"]
            }
        };

        // Extract spacing from Constants
        const spacing = Object.fromEntries(
            Object.entries(Constants.STRUCTURES).map(function(entry) {
                return [entry[0], entry[1].spacing];
            })
        );

        // Minecraft Random (Function-based implementation)
        function MinecraftRandom(seed) {
            var instanceSeed = BigInt(seed) & ((BigInt(1) << BigInt(48)) - BigInt(1));

            return {
                nextInt: function(bound) {
                    instanceSeed = (instanceSeed * BigInt(0x5DEECE66D) + BigInt(0xB)) & ((BigInt(1) << BigInt(48)) - BigInt(1));
                    return Number(instanceSeed >> BigInt(16)) % bound;
                },
                nextFloat: function() {
                    instanceSeed = (instanceSeed * BigInt(0x5DEECE66D) + BigInt(0xB)) & ((BigInt(1) << BigInt(48)) - BigInt(1));
                    return Number(instanceSeed >> BigInt(24)) / (1 << 24);
                }
            };
        }

        // Perlin Noise simulation
        function perlinNoise(x, z, seed, scale, octaves) {
            if (scale === undefined) scale = 0.007;
            if (octaves === undefined) octaves = 8;
            var total = 0;
            for (var i = 0; i < octaves; i++) {
                var freq = scale * Math.pow(2, i);
                var amp = Math.pow(0.5, i);
                var rand = MinecraftRandom(seed + i * 1000);
                var gridX = Math.floor(x * freq), gridZ = Math.floor(z * freq);
                var n00 = rand.nextFloat() * 2 - 1;
                var n10 = rand.nextFloat() * 2 - 1;
                var n01 = rand.nextFloat() * 2 - 1;
                var n11 = rand.nextFloat() * 2 - 1;
                var fx = x * freq - gridX, fz = z * freq - gridZ;
                var u = fx * fx * (3 - 2 * fx), v = fz * fz * (3 - 2 * fz);
                var lerpX0 = n00 + u * (n10 - n00);
                var lerpX1 = n01 + u * (n11 - n01);
                total += (lerpX0 + v * (lerpX1 - lerpX0)) * amp;
            }
            return total;
        }

        // Get biome at position
        function getBiomeAt(seed, x, z, version, dimension) {
            if (dimension === undefined) dimension = "overworld";
            var biomeMap = Constants.BIOME_WEIGHTS[dimension.toUpperCase()] || Constants.BIOME_WEIGHTS.OVERWORLD;
            var noiseSeed = BigInt(seed) + BigInt(x) * BigInt(341873128712) + BigInt(z) * BigInt(132897987541);
            var noise = perlinNoise(x, z, Number(noiseSeed), Constants.WORLD_SETTINGS.NOISE_SCALE, Constants.WORLD_SETTINGS.NOISE_OCTAVES);
            var biomeId = Math.floor((noise + 1) * 100);
            var cumWeight = 0;
            for (var biome in biomeMap) {
                cumWeight += biomeMap[biome] * 100;
                if (biomeId <= cumWeight) return [biome, 1];
            }
            return ["Plains", 1];
        }

        // Structure position calculation
        function getStructurePos(seed, structure, version, radius, filters) {
            if (filters === undefined) filters = {};
            var versionNum = parseFloat(version);
            var biomeRequirements = {
                Village: ["Plains", "Desert", "Savanna", "Taiga", "Meadow"],
                Temple: ["Desert", "Jungle", "Swamp", "Snowy Plains"],
                Monument: ["Ocean"],
                Mansion: ["Forest"],
                "Ancient City": ["Deep Dark"],
                "Bastion Remnant": ["Nether Wastes", "Crimson Forest", "Warped Forest", "Soul Sand Valley", "Basalt Deltas"],
                "Nether Fortress": ["Nether Wastes", "Crimson Forest", "Warped Forest", "Soul Sand Valley", "Basalt Deltas"],
                "Trial Chambers": ["Deep Dark"]
            };
            var structureSeed = seed;
            for (var i = 0; i < structure.length; i++) {
                structureSeed = (structureSeed * 31 + structure.charCodeAt(i)) | 0;
            }
            var rand = MinecraftRandom(seed + BigInt(structureSeed));
            var minDist = Constants.STRUCTURES[structure].minDist;
            var blockX, blockZ;
            if (structure === "Stronghold" && versionNum < 1.18) {
                var ring = rand.nextInt(3);
                var minRadius = [1408, 2720, 4032][ring];
                var maxRadius = [2688, 4000, 5312][ring];
                var angle = rand.nextFloat() * 2 * Math.PI;
                var distance = minRadius + rand.nextFloat() * (maxRadius - minRadius);
                blockX = Math.round(Math.cos(angle) * distance);
                blockZ = Math.round(Math.sin(angle) * distance);
            } else {
                var regionSize = spacing[structure] * Constants.WORLD_SETTINGS.CHUNK_SIZE;
                var regionX = rand.nextInt(Math.floor(radius / regionSize * 2)) - Math.floor(radius / regionSize);
                var regionZ = rand.nextInt(Math.floor(radius / regionSize * 2)) - Math.floor(radius / regionSize);
                blockX = (regionX * regionSize) + rand.nextInt(regionSize);
                blockZ = (regionZ * regionSize) + rand.nextInt(regionSize);
            }
            var distance = Math.sqrt(blockX * blockX + blockZ * blockZ);
            if (distance <= radius && distance >= minDist * Constants.WORLD_SETTINGS.CHUNK_SIZE) {
                if (filters.stronghold_distance && structure === "Stronghold" && distance > filters.stronghold_distance) {
                    return null;
                }
                var dimension = ["Bastion Remnant", "Nether Fortress"].indexOf(structure) !== -1 ? "nether" : "overworld";
                var offsets = [[0, 0], [8, 8], [-8, -8], [8, -8], [-8, 8]];
                for (var i = 0; i < offsets.length; i++) {
                    var offset = offsets[i];
                    var dx = offset[0], dz = offset[1];
                    var biomeResult = getBiomeAt(seed, blockX + dx, blockZ + dz, version, dimension);
                    var biome = biomeResult[0];
                    if (!biomeRequirements[structure] || biomeRequirements[structure].indexOf(biome) === -1) return null;
                }
                var desc = structure;
                if (structure === "Temple") {
                    var templeTypes = ["Desert", "Jungle", "Swamp", "Igloo"];
                    var templeType = templeTypes[rand.nextInt(templeTypes.length)];
                    if (filters.temple_type && filters.temple_type !== "Any" && templeType !== filters.temple_type) return null;
                    desc = "Temple (" + templeType + ")";
                } else if (structure === "Bastion Remnant") {
                    var bastionTypes = ["Hoglin Stable", "Housing Units", "Treasure", "Bridge"];
                    var bastionType = bastionTypes[rand.nextInt(bastionTypes.length)];
                    if (filters.bastion_type && filters.bastion_type !== "Any" && bastionType !== filters.bastion_type) return null;
                    desc = "Bastion Remnant (" + bastionType + ")";
                }
                return [blockX, blockZ, desc, distance];
            }
            return null;
        }

        // Biome distribution analysis
        function analyzeBiomeDistribution(seed, version, radius, dimension) {
            if (radius === undefined) radius = 4000;
            if (dimension === undefined) dimension = "overworld";
            var biomeCounts = {};
            var step = Math.floor(radius / 50);
            var points = Array.from({ length: 100 }, function(_, i) {
                return -radius + (i * 2 * radius) / 99;
            });
            for (var i = 0; i < points.length; i++) {
                var x = points[i];
                for (var j = 0; j < points.length; j++) {
                    var z = points[j];
                    var biomeResult = getBiomeAt(seed, Math.floor(x), Math.floor(z), version, dimension);
                    var biome = biomeResult[0];
                    biomeCounts[biome] = (biomeCounts[biome] || 0) + 1;
                }
            }
            var total = Object.values(biomeCounts).reduce(function(s, c) { return s + c; }, 0);
            var result = {};
            for (var b in biomeCounts) {
                result[b] = (biomeCounts[b] / total * 100);
            }
            return result;
        }

        // Log seed to localStorage
        function logSeed(seed, version, biomes, structures, radius, filters, status, structurePositions) {
            if (structurePositions === undefined) structurePositions = null;
            try {
                var timestamp = new Date().toISOString();
                var logEntry = {
                    timestamp: timestamp,
                    seed: seed,
                    version: version,
                    biomes: biomes,
                    structures: structures,
                    radius: radius,
                    filters: filters,
                    status: status,
                    spawnBiomes: Array.from({ length: 25 }, function(_, i) {
                        var x = [-32, -16, 0, 16, 32][Math.floor(i / 5)];
                        var z = [-32, -16, 0, 16, 32][i % 5];
                        var biomeResult = getBiomeAt(seed, x, z, version, "overworld");
                        var biome = biomeResult[0];
                        return "(" + x + ", " + z + "): " + biome;
                    }),
                    structurePositions: structurePositions
                };
                var logs = JSON.parse(localStorage.getItem("seedLogs") || "[]");
                logs.push(logEntry);
                if (logs.length > 100) logs.shift();
                localStorage.setItem("seedLogs", JSON.stringify(logs));
            } catch (e) {
                console.error("Failed to save log to localStorage:", e);
            }
        }

        // Main React App
        function App() {
            var versionState = React.useState("1.21");
            var version = versionState[0], setVersion = versionState[1];
            var biomesState = React.useState(["Plains"]);
            var biomes = biomesState[0], setBiomes = biomesState[1];
            var structuresState = React.useState([]);
            var structures = structuresState[0], setStructures = structuresState[1];
            var radiusState = React.useState(500);
            var radius = radiusState[0], setRadius = radiusState[1];
            var priorityState = React.useState("none");
            var priority = priorityState[0], setPriority = priorityState[1];
            var filtersState = React.useState({ temple_type: "Any", bastion_type: "Any", stronghold_distance: 0 });
            var filters = filtersState[0], setFilters = filtersState[1];
            var currentSeedState = React.useState(null);
            var currentSeed = currentSeedState[0], setCurrentSeed = currentSeedState[1];
            var positionsState = React.useState({});
            var positions = positionsState[0], setPositions = positionsState[1];
            var biomeDistState = React.useState({});
            var biomeDist = biomeDistState[0], setBiomeDist = biomeDistState[1];
            var biomeDistNetherState = React.useState({});
            var biomeDistNether = biomeDistNetherState[0], setBiomeDistNether = biomeDistNetherState[1];
            var isRunningState = React.useState(false);
            var isRunning = isRunningState[0], setIsRunning = isRunningState[1];
            var progressState = React.useState(0);
            var progress = progressState[0], setProgress = progressState[1];
            var attemptsState = React.useState(0);
            var attempts = attemptsState[0], setAttempts = attemptsState[1];
            var startTimeState = React.useState(0);
            var startTime = startTimeState[0], setStartTime = startTimeState[1];
            var resultState = React.useState("");
            var result = resultState[0], setResult = resultState[1];
            var dimensionState = React.useState("overworld");
            var dimension = dimensionState[0], setDimension = dimensionState[1];
            var zoomState = React.useState(1.0);
            var zoom = zoomState[0], setZoom = zoomState[1];
            var panOffsetState = React.useState({ x: 0, y: 0 });
            var panOffset = panOffsetState[0], setPanOffset = panOffsetState[1];
            var panStartState = React.useState({ x: 0, y: 0 });
            var panStart = panStartState[0], setPanStart = panStartState[1];
            var isPanningState = React.useState(false);
            var isPanning = isPanningState[0], setIsPanning = isPanningState[1];
            var profilesState = React.useState(JSON.parse(localStorage.getItem("profiles") || "{}"));
            var profiles = profilesState[0], setProfiles = profilesState[1];
            var selectedProfileState = React.useState("");
            var selectedProfile = selectedProfileState[0], setSelectedProfile = selectedProfileState[1];
            var errorState = React.useState("");
            var error = errorState[0], setError = errorState[1];
            var canvasRef = React.useRef(null);
            var workerRef = React.useRef(null);

            // Biome and structure options
            var biomeOptions = Object.keys(Constants.BIOME_WEIGHTS.OVERWORLD);
            var structureOptions = Object.keys(Constants.STRUCTURES).filter(function(s) {
                return ["End City", "Ruined Portal"].indexOf(s) === -1;
            });

            // Initialize Web Worker
            React.useEffect(function() {
                try {
                    workerRef.current = new Worker(URL.createObjectURL(new Blob([
                        MinecraftRandom.toString() + "\n" +
                        perlinNoise.toString() + "\n" +
                        getBiomeAt.toString() + "\n" +
                        getStructurePos.toString() + "\n" +
                        analyzeBiomeDistribution.toString() + "\n" +
                        "self.Constants = " + JSON.stringify(Constants) + ";\n" +
                        "self.spacing = " + JSON.stringify(spacing) + ";\n" +
                        "self.onmessage = function(e) {\n" +
                        "    var data = e.data;\n" +
                        "    var seed = data.seed, version = data.version, biomes = data.biomes, structures = data.structures, radius = data.radius, filters = data.filters, maxAttempts = data.maxAttempts;\n" +
                        "    var attempts = 0;\n" +
                        "    while (attempts < maxAttempts) {\n" +
                        "        var currentSeed = BigInt(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER - Number.MAX_SAFE_INTEGER / 2));\n" +
                        "        var biomeValid = true;\n" +
                        "        for (var i = 0; i < biomes.length; i++) {\n" +
                        "            var biome = biomes[i];\n" +
                        "            var found = false;\n" +
                        "            for (var j = 0; j < [-32, -16, 0, 16, 32].length; j++) {\n" +
                        "                var x = [-32, -16, 0, 16, 32][j];\n" +
                        "                for (var k = 0; k < [-32, -16, 0, 16, 32].length; k++) {\n" +
                        "                    var z = [-32, -16, 0, 16, 32][k];\n" +
                        "                    var biomeResult = getBiomeAt(currentSeed, x, z, version, 'overworld');\n" +
                        "                    if (biomeResult[0] === biome) {\n" +
                        "                        found = true;\n" +
                        "                        break;\n" +
                        "                    }\n" +
                        "                }\n" +
                        "                if (found) break;\n" +
                        "            }\n" +
                        "            if (!found) {\n" +
                        "                biomeValid = false;\n" +
                        "                break;\n" +
                        "            }\n" +
                        "        }\n" +
                        "        var status = biomeValid ? null : 'Rejected: Biomes not matched';\n" +
                        "        var structurePositions = {};\n" +
                        "        var totalDistance = 0;\n" +
                        "        if (biomeValid) {\n" +
                        "            var valid = true;\n" +
                        "            for (var i = 0; i < structures.length; i++) {\n" +
                        "                var struct = structures[i];\n" +
                        "                var pos = getStructurePos(currentSeed, struct, version, radius, filters);\n" +
                        "                if (pos) {\n" +
                        "                    structurePositions[struct] = pos;\n" +
                        "                    totalDistance += pos[3];\n" +
                        "                } else {\n" +
                        "                    valid = false;\n" +
                        "                    status = 'Rejected: ' + struct + ' not found';\n" +
                        "                    break;\n" +
                        "                }\n" +
                        "            }\n" +
                        "            if (valid && priority === 'distance' && totalDistance > radius * structures.length * 0.3) {\n" +
                        "                valid = false;\n" +
                        "                status = 'Rejected: Structures too far';\n" +
                        "            }\n" +
                        "            if (valid) {\n" +
                        "                var biomeDist = analyzeBiomeDistribution(currentSeed, version, 4000, 'overworld');\n" +
                        "                var biomeDistNether = analyzeBiomeDistribution(currentSeed, version, 4000, 'nether');\n" +
                        "                self.postMessage({\n" +
                        "                    seed: Number(currentSeed),\n" +
                        "                    status: 'Accepted',\n" +
                        "                    structurePositions: structurePositions,\n" +
                        "                    biomeDist: biomeDist,\n" +
                        "                    biomeDistNether: biomeDistNether,\n" +
                        "                    attempts: attempts\n" +
                        "                });\n" +
                        "                return;\n" +
                        "            }\n" +
                        "        }\n" +
                        "        attempts++;\n" +
                        "        if (attempts % 100 === 0) {\n" +
                        "            self.postMessage({ progress: Math.min(attempts / maxAttempts * 100, 99.9), attempts: attempts });\n" +
                        "        }\n" +
                        "    }\n" +
                        "    self.postMessage({ status: 'No valid seed found', attempts: attempts });\n" +
                        "};\n"
                    ], { type: "text/javascript" })));
                    workerRef.current.onmessage = function(e) {
                        var data = e.data;
                        var seed = data.seed, status = data.status, structurePositions = data.structurePositions, biomeDist = data.biomeDist, biomeDistNether = data.biomeDistNether, progress = data.progress, attempts = data.attempts;
                        setProgress(progress || 0);
                        setAttempts(attempts || 0);
                        if (status === "Accepted") {
                            setCurrentSeed(seed);
                            setPositions(structurePositions);
                            setBiomeDist(biomeDist);
                            setBiomeDistNether(biomeDistNether);
                            var structureLines = [];
                            for (var key in structurePositions) {
                                var pos = structurePositions[key];
                                var x = pos[0], z = pos[1], desc = pos[2], dist = pos[3];
                                structureLines.push("  " + desc + " at (" + x + ", " + z + ") (Distance: " + dist.toFixed(1) + ")");
                            }
                            structureLines.sort(function(a, b) {
                                var distA = parseFloat(a.match(/Distance: ([\d.]+)/)[1]);
                                var distB = parseFloat(b.match(/Distance: ([\d.]+)/)[1]);
                                return distA - distB;
                            });
                            var biomeDistLines = [];
                            for (var b in biomeDist) {
                                biomeDistLines.push("  " + b + ": " + biomeDist[b].toFixed(2) + "%");
                            }
                            biomeDistLines.sort(function(a, b) {
                                var percentA = parseFloat(a.match(/([\d.]+)%/)[1]);
                                var percentB = parseFloat(b.match(/([\d.]+)%/)[1]);
                                return percentB - percentA;
                            });
                            var biomeDistNetherLines = [];
                            for (var b in biomeDistNether) {
                                biomeDistNetherLines.push("  " + b + ": " + biomeDistNether[b].toFixed(2) + "%");
                            }
                            biomeDistNetherLines.sort(function(a, b) {
                                var percentA = parseFloat(a.match(/([\d.]+)%/)[1]);
                                var percentB = parseFloat(b.match(/([\d.]+)%/)[1]);
                                return percentB - percentA;
                            });
                            setResult(
                                "Seed: " + seed + "\n" +
                                "Biomes: " + biomes.join(", ") + "\n" +
                                "Version: " + version + "\n" +
                                "Structures:\n" +
                                structureLines.join("\n") + "\n" +
                                "Biome Distribution (Overworld, 4000x4000 blocks):\n" +
                                biomeDistLines.join("\n") + "\n" +
                                "Biome Distribution (Nether, 4000x4000 blocks):\n" +
                                biomeDistNetherLines.join("\n")
                            );
                            logSeed(seed, version, biomes, structures, radius, filters, "Accepted", structurePositions);
                            setIsRunning(false);
                        } else if (status === "No valid seed found") {
                            setResult("No valid seed found. Try again!");
                            setIsRunning(false);
                        }
                    };
                } catch (e) {
                    console.error("Failed to initialize Web Worker:", e);
                    setError("Failed to initialize seed generation!");
                    setIsRunning(false);
                }
                return function() {
                    if (workerRef.current) workerRef.current.terminate();
                };
            }, []);

            // Draw map on canvas
            var canvasData = React.useMemo(function() {
                if (Object.keys(positions).length === 0) return null;
                var scale = 600 / (2 * radius) * zoom;
                var biomeColors = {
                    "Plains": "#90EE90", "Forest": "#228B22", "Desert": "#EDC9AF", "Taiga": "#2F4F4F",
                    "Swamp": "#6B8E23", "Jungle": "#006400", "Savanna": "#DAA520", "Badlands": "#8B0000",
                    "Mushroom Fields": "#FFE4E1", "Deep Dark": "#1C2526", "Mangrove Swamp": "#3CB371",
                    "Cherry Grove": "#FF69B4", "Lush Caves": "#00CED1", "Snowy Plains": "#F0F8FF",
                    "Ocean": "#1E90FF", "Meadow": "#98FB98", "Bamboo Jungle": "#9ACD32",
                    "Nether Wastes": "#8B0000", "Crimson Forest": "#DC143C", "Warped Forest": "#20B2AA",
                    "Soul Sand Valley": "#B0C4DE", "Basalt Deltas": "#696969"
                };
                var structureColors = {
                    "Village": "yellow", "Mineshaft": "gray", "Stronghold": "purple", "Temple": "orange",
                    "Monument": "blue", "Mansion": "brown", "Bastion Remnant": "black", "Ancient City": "cyan",
                    "Nether Fortress": "red", "Trial Chambers": "magenta"
                };
                return { scale: scale, biomeColors: biomeColors, structureColors: structureColors };
            }, [positions, radius, zoom]);

            React.useEffect(function() {
                if (!canvasData) return;
                var canvas = canvasRef.current;
                var ctx = canvas.getContext("2d");
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                var scale = canvasData.scale;
                var biomeColors = canvasData.biomeColors;
                var structureColors = canvasData.structureColors;
                var step = Math.floor(4000 / 80);
                for (var x = -4000; x <= 4000; x += step) {
                    for (var z = -4000; z <= 4000; z += step) {
                        var biomeResult = getBiomeAt(currentSeed || 0, x, z, version, dimension);
                        var biome = biomeResult[0];
                        var cx = 300 + (x * scale + panOffset.x);
                        var cy = 300 + (z * scale + panOffset.y);
                        ctx.fillStyle = biomeColors[biome] || "#2b2b2b";
                        ctx.globalAlpha = 0.5;
                        ctx.fillRect(cx - step * scale, cy - step * scale, step * scale * 2, step * scale * 2);
                        ctx.globalAlpha = 1.0;
                    }
                }
                if (dimension === "overworld") {
                    ctx.fillStyle = "red";
                    ctx.beginPath();
                    ctx.arc(300, 300, 6, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.strokeStyle = "black";
                    ctx.stroke();
                }
                for (var struct in positions) {
                    var pos = positions[struct];
                    var x = pos[0], z = pos[1], desc = pos[2];
                    if (dimension === "nether" && ["Bastion Remnant", "Nether Fortress"].indexOf(struct) === -1) continue;
                    if (dimension === "overworld" && ["Bastion Remnant", "Nether Fortress"].indexOf(struct) !== -1) continue;
                    var cx = 300 + (x * scale + panOffset.x);
                    var cy = 300 + (z * scale + panOffset.y);
                    ctx.fillStyle = structureColors[struct] || "white";
                    ctx.beginPath();
                    ctx.arc(cx, cy, 6, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.strokeStyle = "black";
                    ctx.stroke();
                    ctx.fillStyle = "#e0e0e0";
                    ctx.font = "12px Arial";
                    ctx.fillText(desc, cx + 10, cy + 4);
                }
            }, [canvasData, dimension, panOffset, currentSeed, version]);

            // Find valid seed using Web Worker
            function findValidSeed() {
                setIsRunning(true);
                setProgress(0);
                setAttempts(0);
                setStartTime(Date.now());
                setResult("Generating seed, please wait...");
                setError("");
                if (workerRef.current) {
                    workerRef.current.postMessage({
                        seed: 0,
                        version: version,
                        biomes: biomes,
                        structures: structures,
                        radius: radius,
                        filters: filters,
                        maxAttempts: Constants.WORLD_SETTINGS.SEARCH_ITERATIONS
                    });
                } else {
                    setError("Web Worker not initialized!");
                    setIsRunning(false);
                }
            }

            // Stop seed search
            function stopSearch() {
                if (workerRef.current) {
                    workerRef.current.terminate();
                    workerRef.current = new Worker(URL.createObjectURL(new Blob([
                        MinecraftRandom.toString() + "\n" +
                        perlinNoise.toString() + "\n" +
                        getBiomeAt.toString() + "\n" +
                        getStructurePos.toString() + "\n" +
                        analyzeBiomeDistribution.toString() + "\n" +
                        "self.Constants = " + JSON.stringify(Constants) + ";\n" +
                        "self.spacing = " + JSON.stringify(spacing) + ";\n" +
                        "self.onmessage = function(e) {\n" +
                        "    var data = e.data;\n" +
                        "    var seed = data.seed, version = data.version, biomes = data.biomes, structures = data.structures, radius = data.radius, filters = data.filters, maxAttempts = data.maxAttempts;\n" +
                        "    var attempts = 0;\n" +
                        "    while (attempts < maxAttempts) {\n" +
                        "        var currentSeed = BigInt(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER - Number.MAX_SAFE_INTEGER / 2));\n" +
                        "        var biomeValid = true;\n" +
                        "        for (var i = 0; i < biomes.length; i++) {\n" +
                        "            var biome = biomes[i];\n" +
                        "            var found = false;\n" +
                        "            for (var j = 0; j < [-32, -16, 0, 16, 32].length; j++) {\n" +
                        "                var x = [-32, -16, 0, 16, 32][j];\n" +
                        "                for (var k = 0; k < [-32, -16, 0, 16, 32].length; k++) {\n" +
                        "                    var z = [-32, -16, 0, 16, 32][k];\n" +
                        "                    var biomeResult = getBiomeAt(currentSeed, x, z, version, 'overworld');\n" +
                        "                    if (biomeResult[0] === biome) {\n" +
                        "                        found = true;\n" +
                        "                        break;\n" +
                        "                    }\n" +
                        "                }\n" +
                        "                if (found) break;\n" +
                        "            }\n" +
                        "            if (!found) {\n" +
                        "                biomeValid = false;\n" +
                        "                break;\n" +
                        "            }\n" +
                        "        }\n" +
                        "        var status = biomeValid ? null : 'Rejected: Biomes not matched';\n" +
                        "        var structurePositions = {};\n" +
                        "        var totalDistance = 0;\n" +
                        "        if (biomeValid) {\n" +
                        "            var valid = true;\n" +
                        "            for (var i = 0; i < structures.length; i++) {\n" +
                        "                var struct = structures[i];\n" +
                        "                var pos = getStructurePos(currentSeed, struct, version, radius, filters);\n" +
                        "                if (pos) {\n" +
                        "                    structurePositions[struct] = pos;\n" +
                        "                    totalDistance += pos[3];\n" +
                        "                } else {\n" +
                        "                    valid = false;\n" +
                        "                    status = 'Rejected: ' + struct + ' not found';\n" +
                        "                    break;\n" +
                        "                }\n" +
                        "            }\n" +
                        "            if (valid && priority === 'distance' && totalDistance > radius * structures.length * 0.3) {\n" +
                        "                valid = false;\n" +
                        "                status = 'Rejected: Structures too far';\n" +
                        "            }\n" +
                        "            if (valid) {\n" +
                        "                var biomeDist = analyzeBiomeDistribution(currentSeed, version, 4000, 'overworld');\n" +
                        "                var biomeDistNether = analyzeBiomeDistribution(currentSeed, version, 4000, 'nether');\n" +
                        "                self.postMessage({\n" +
                        "                    seed: Number(currentSeed),\n" +
                        "                    status: 'Accepted',\n" +
                        "                    structurePositions: structurePositions,\n" +
                        "                    biomeDist: biomeDist,\n" +
                        "                    biomeDistNether: biomeDistNether,\n" +
                        "                    attempts: attempts\n" +
                        "                });\n" +
                        "                return;\n" +
                        "            }\n" +
                        "        }\n" +
                        "        attempts++;\n" +
                        "        if (attempts % 100 === 0) {\n" +
                        "            self.postMessage({ progress: Math.min(attempts / maxAttempts * 100, 99.9), attempts: attempts });\n" +
                        "        }\n" +
                        "    }\n" +
                        "    self.postMessage({ status: 'No valid seed found', attempts: attempts });\n" +
                        "};\n"
                    ], { type: "text/javascript" })));
                    setIsRunning(false);
                    setResult("Search stopped.");
                }
            }

            // Handle biome addition
            function addBiome(biome) {
                if (biomes.length < 3) {
                    setBiomes(biomes.concat([biome]));
                    setError("");
                } else {
                    setError("Maximum 3 biomes allowed!");
                }
            }

            // Handle structure toggle
            function toggleStructure(struct) {
                if (structures.indexOf(struct) !== -1) {
                    setStructures(structures.filter(function(s) { return s !== struct; }));
                    setError("");
                } else if (structures.length < 3) {
                    setStructures(structures.concat([struct]));
                    setError("");
                } else {
                    setError("Maximum 3 structures allowed!");
                }
            }

            // Save profile
            function saveProfile() {
                var name = prompt("Enter profile name:");
                if (name) {
                    try {
                        var profile = { version: version, biomes: biomes, structures: structures, radius: radius, priority: priority, filters: filters };
                        var newProfiles = Object.assign({}, profiles, {});
                        newProfiles[name] = profile;
                        setProfiles(newProfiles);
                        localStorage.setItem("profiles", JSON.stringify(newProfiles));
                        setSelectedProfile(name);
                        setError("");
                    } catch (e) {
                        setError("Failed to save profile!");
                    }
                }
            }

            // Load profile
            function loadProfile(name) {
                if (profiles[name]) {
                    var profile = profiles[name];
                    var version = profile.version, biomes = profile.biomes, structures = profile.structures, radius = profile.radius, priority = profile.priority, filters = profile.filters;
                    setVersion(version);
                    setBiomes(biomes);
                    setStructures(structures);
                    setRadius(radius);
                    setPriority(priority);
                    setFilters(filters);
                    setSelectedProfile(name);
                    setError("");
                }
            }

            // Delete profile
            function deleteProfile() {
                if (selectedProfile) {
                    try {
                        var newProfiles = Object.assign({}, profiles);
                        delete newProfiles[selectedProfile];
                        setProfiles(newProfiles);
                        localStorage.setItem("profiles", JSON.stringify(newProfiles));
                        setSelectedProfile("");
                        setError("");
                    } catch (e) {
                        setError("Failed to delete profile!");
                    }
                }
            }

            // Export results
            function exportResults() {
                if (!currentSeed) {
                    setError("No seed to export!");
                    return;
                }
                try {
                    var result = {
                        seed: currentSeed,
                        biomes: biomes,
                        structures: positions,
                        radius: radius,
                        version: version,
                        biome_distribution_overworld: biomeDist,
                        biome_distribution_nether: biomeDistNether,
                        timestamp: new Date().toISOString(),
                        criteria: Object.assign({ priority: priority }, filters)
                    };
                    var blob = new Blob([JSON.stringify(result, null, 2)], { type: "application/json" });
                    var url = URL.createObjectURL(blob);
                    var a = document.createElement("a");
                    a.href = url;
                    a.download = "seed_result.json";
                    a.click();
                    URL.revokeObjectURL(url);
                    setError("");
                } catch (e) {
                    setError("Failed to export results!");
                }
            }

            // Copy seed
            function copySeed() {
                if (currentSeed) {
                    try {
                        navigator.clipboard.writeText(String(currentSeed));
                        setError("");
                        alert("Seed copied to clipboard!");
                    } catch (e) {
                        setError("Failed to copy seed!");
                    }
                } else {
                    setError("No seed to copy!");
                }
            }

            // Handle canvas panning
            function startPan(e) {
                setIsPanning(true);
                setPanStart({ x: e.clientX, y: e.clientY });
            }
            function pan(e) {
                if (!isPanning) return;
                setPanOffset({
                    x: panOffset.x + (e.clientX - panStart.x),
                    y: panOffset.y + (e.clientY - panStart.y)
                });
                setPanStart({ x: e.clientX, y: e.clientY });
            }
            function stopPan() {
                setIsPanning(false);
            }

            // Reset settings
            function resetSettings() {
                setVersion("1.21");
                setBiomes(["Plains"]);
                setStructures([]);
                setRadius(500);
                setPriority("none");
                setFilters({ temple_type: "Any", bastion_type: "Any", stronghold_distance: 0 });
                setSelectedProfile("");
                setError("");
                setCurrentSeed(null);
                setPositions({});
                setBiomeDist({});
                setBiomeDistNether({});
                setResult("");
                setZoom(1.0);
                setPanOffset({ x: 0, y: 0 });
            }

            return (
                React.createElement("div", { className: "flex h-screen bg-gray-900 text-gray-100" },
                    // Left Control Panel
                    React.createElement("div", { className: "w-96 bg-gray-800 p-6 overflow-y-auto scrollbar-custom" },
                        React.createElement("h1", { className: "text-2xl font-bold text-green-400 mb-6" }, "Minecraft Seed Generator"),
                        error && React.createElement("p", { className: "text-red-500 text-sm mb-4" }, error),
                        // Version Selection
                        React.createElement("label", { className: "block text-sm mb-2" }, "Minecraft Version:"),
                        React.createElement("select", {
                            value: version,
                            onChange: function(e) { setVersion(e.target.value); },
                            className: "w-full bg-gray-700 text-white p-2 rounded mb-4"
                        }, ["1.14", "1.15", "1.16", "1.17", "1.18", "1.19", "1.20", "1.21"].map(function(v) {
                            return React.createElement("option", { key: v, value: v }, v);
                        })),
                        // Biome Selection
                        React.createElement("label", { className: "block text-sm mb-2" }, "Spawn Biomes (up to 3):"),
                        React.createElement("div", { className: "mb-4" },
                            biomes.map(function(b, i) {
                                return React.createElement("select", {
                                    key: i,
                                    value: b,
                                    onChange: function(e) {
                                        setBiomes(biomes.map(function(b2, j) { return i === j ? e.target.value : b2; }));
                                    },
                                    className: "w-full bg-gray-700 text-white p-2 rounded mb-2"
                                }, biomeOptions.map(function(o) {
                                    return React.createElement("option", { key: o, value: o }, o);
                                }));
                            }),
                            React.createElement("button", {
                                onClick: function() { addBiome(biomeOptions[0]); },
                                className: "bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600 transition"
                            }, "Add Biome")
                        ),
                        // Structure Selection
                        React.createElement("label", { className: "block text-sm mb-2" }, "Structures (up to 3):"),
                        React.createElement("div", { className: "grid grid-cols-2 gap-2 mb-4" },
                            structureOptions.map(function(s) {
                                return React.createElement("label", { key: s, className: "flex items-center" },
                                    React.createElement("input", {
                                        type: "checkbox",
                                        checked: structures.indexOf(s) !== -1,
                                        onChange: function() { toggleStructure(s); },
                                        className: "mr-2"
                                    }),
                                    s
                                );
                            })
                        ),
                        // Structure Filters
                        React.createElement("label", { className: "block text-sm mb-2" }, "Structure Filters:"),
                        React.createElement("div", { className: "mb-4" },
                            React.createElement("label", { className: "block text-xs mb-1" }, "Temple Type:"),
                            React.createElement("select", {
                                value: filters.temple_type,
                                onChange: function(e) { setFilters(Object.assign({}, filters, { temple_type: e.target.value })); },
                                className: "w-full bg-gray-700 text-white p-2 rounded mb-2"
                            }, ["Any", "Desert", "Jungle", "Swamp", "Igloo"].map(function(t) {
                                return React.createElement("option", { key: t, value: t }, t);
                            })),
                            React.createElement("label", { className: "block text-xs mb-1" }, "Bastion Type:"),
                            React.createElement("select", {
                                value: filters.bastion_type,
                                onChange: function(e) { setFilters(Object.assign({}, filters, { bastion_type: e.target.value })); },
                                className: "w-full bg-gray-700 text-white p-2 rounded mb-2"
                            }, ["Any", "Hoglin Stable", "Housing Units", "Treasure", "Bridge"].map(function(t) {
                                return React.createElement("option", { key: t, value: t }, t);
                            })),
                            React.createElement("label", { className: "block text-xs mb-1" }, "Max Stronghold Distance:"),
                            React.createElement("input", {
                                type: "number",
                                value: filters.stronghold_distance,
                                onChange: function(e) { setFilters(Object.assign({}, filters, { stronghold_distance: parseFloat(e.target.value) || 0 })); },
                                className: "w-full bg-gray-700 text-white p-2 rounded"
                            })
                        ),
                        // Priority Selection
                        React.createElement("label", { className: "block text-sm mb-2" }, "Priority:"),
                        React.createElement("div", { className: "mb-4" },
                            React.createElement("label", { className: "flex items-center mb-2" },
                                React.createElement("input", {
                                    type: "radio",
                                    name: "priority",
                                    value: "none",
                                    checked: priority === "none",
                                    onChange: function(e) { setPriority(e.target.value); },
                                    className: "mr-2"
                                }),
                                "None"
                            ),
                            React.createElement("label", { className: "flex items-center" },
                                React.createElement("input", {
                                    type: "radio",
                                    name: "priority",
                                    value: "distance",
                                    checked: priority === "distance",
                                    onChange: function(e) { setPriority(e.target.value); },
                                    className: "mr-2"
                                }),
                                "Closer Structures"
                            )
                        ),
                        // Radius Slider
                        React.createElement("label", { className: "block text-sm mb-2" }, "Search Radius (blocks): ", radius),
                        React.createElement("input", {
                            type: "range",
                            min: "100",
                            max: "4000",
                            value: radius,
                            onChange: function(e) { setRadius(parseInt(e.target.value)); },
                            className: "w-full mb-4"
                        }),
                        // Profile Management
                        React.createElement("label", { className: "block text-sm mb-2" }, "Saved Profiles:"),
                        React.createElement("select", {
                            value: selectedProfile,
                            onChange: function(e) { loadProfile(e.target.value); },
                            className: "w-full bg-gray-700 text-white p-2 rounded mb-2"
                        },
                            React.createElement("option", { value: "" }, "Select Profile"),
                            Object.keys(profiles).map(function(p) {
                                return React.createElement("option", { key: p, value: p }, p);
                            })
                        ),
                        React.createElement("div", { className: "flex gap-2 mb-4" },
                            React.createElement("button", {
                                onClick: saveProfile,
                                className: "bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 transition"
                            }, "Save Profile"),
                            React.createElement("button", {
                                onClick: deleteProfile,
                                className: "bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600 transition"
                            }, "Delete Profile")
                        ),
                        // Controls
                        React.createElement("div", { className: "flex flex-col gap-2 mb-4" },
                            React.createElement("button", {
                                onClick: findValidSeed,
                                disabled: isRunning,
                                className: "px-4 py-2 rounded transition " + (isRunning ? "bg-gray-500 cursor-not-allowed" : "bg-green-500 hover:bg-green-600") + " text-white"
                            }, "Generate Seed"),
                            React.createElement("button", {
                                onClick: stopSearch,
                                disabled: !isRunning,
                                className: "px-4 py-2 rounded transition " + (!isRunning ? "bg-gray-500 cursor-not-allowed" : "bg-red-500 hover:bg-red-600") + " text-white"
                            }, "Stop Search"),
                            React.createElement("button", {
                                onClick: exportResults,
                                disabled: !currentSeed,
                                className: "px-4 py-2 rounded transition " + (!currentSeed ? "bg-gray-500 cursor-not-allowed" : "bg-blue-500 hover:bg-blue-600") + " text-white"
                            }, "Export Results"),
                            React.createElement("button", {
                                onClick: copySeed,
                                disabled: !currentSeed,
                                className: "px-4 py-2 rounded transition " + (!currentSeed ? "bg-gray-500 cursor-not-allowed" : "bg-purple-500 hover:bg-purple-600") + " text-white"
                            }, "Copy Seed"),
                            React.createElement("button", {
                                onClick: resetSettings,
                                className: "bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600 transition"
                            }, "Reset Settings")
                        ),
                        // Progress and Stats
                        React.createElement("div", { className: "mb-4" },
                            React.createElement("div", { className: "w-full bg-gray-700 rounded-full h-2.5 mb-2" },
                                React.createElement("div", { className: "bg-green-500 h-2.5 rounded-full", style: { width: progress + "%" } })
                            ),
                            React.createElement("p", { className: "text-sm" }, "Attempts: ", attempts, " | Time: ", ((Date.now() - startTime) / 1000).toFixed(1), "s")
                        ),
                        // Result Display
                        React.createElement("textarea", {
                            value: result,
                            readOnly: true,
                            className: "w-full h-48 bg-gray-700 text-white p-2 rounded resize-none"
                        })
                    ),
                    // Right Map Panel
                    React.createElement("div", { className: "flex-1 p-6" },
                        React.createElement("h2", { className: "text-xl font-bold text-green-400 mb-4" }, "Map Preview"),
                        React.createElement("div", { className: "flex gap-4 mb-4" },
                            React.createElement("label", { className: "flex items-center" },
                                React.createElement("input", {
                                    type: "radio",
                                    name: "dimension",
                                    value: "overworld",
                                    checked: dimension === "overworld",
                                    onChange: function(e) { setDimension(e.target.value); },
                                    className: "mr-2"
                                }),
                                "Overworld"
                            ),
                            React.createElement("label", { className: "flex items-center" },
                                React.createElement("input", {
                                    type: "radio",
                                    name: "dimension",
                                    value: "nether",
                                    checked: dimension === "nether",
                                    onChange: function(e) { setDimension(e.target.value); },
                                    className: "mr-2"
                                }),
                                "Nether"
                            )
                        ),
                        React.createElement("canvas", {
                            ref: canvasRef,
                            width: 600,
                            height: 600,
                            className: "border-2 border-gray-700 rounded",
                            onMouseDown: startPan,
                            onMouseMove: pan,
                            onMouseUp: stopPan,
                            onMouseLeave: stopPan
                        }),
                        React.createElement("label", { className: "block text-sm mt-4 mb-2" }, "Zoom: ", zoom.toFixed(1), "x"),
                        React.createElement("input", {
                            type: "range",
                            min: "0.5",
                            max: "4.0",
                            step: "0.1",
                            value: zoom,
                            onChange: function(e) { setZoom(parseFloat(e.target.value)); },
                            className: "w-full"
                        })
                    )
                )
            );
        }

        // Render App
        var root = ReactDOM.createRoot(document.getElementById("root"));
        root.render(React.createElement(App));
    </script>
</body>
</html>